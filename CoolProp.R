# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.5
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

##   Generated via the command line invocation:
##	 C:\swigwin-3.0.2\swig.exe -r -outdir C:/Users/ian/slave/R-windows/build/build -c++ -IC:/Users/ian/slave/R-windows/build -IC:/Users/ian/slave/R-windows/build/externals/Eigen -IC:/Users/ian/slave/R-windows/build/externals/msgpack-c/include -IC:/Users/ian/slave/R-windows/build/externals/cppformat -IC:/Users/ian/slave/R-windows/build/include -IC:/Users/ian/slave/R-windows/build/src -IC:/PROGRA~1/R/R-32~1.1/include -o C:/Users/ian/slave/R-windows/build/build/CoolPropR_wrap.cxx C:/Users/ian/slave/R-windows/build/src/CoolProp.i


#                         srun.swg                            #
#
# This is the basic code that is needed at run time within R to
# provide and define the relevant classes.  It is included
# automatically in the generated code by copying the contents of
# srun.swg into the newly created binding code.


# This could be provided as a separate run-time library but this
# approach allows the code to to be included directly into the
# generated bindings and so removes the need to have and install an
# additional library.  We may however end up with multiple copies of
# this and some confusion at run-time as to which class to use. This
# is an issue when we use NAMESPACES as we may need to export certain
# classes.

######################################################################

if(length(getClassDef("RSWIGStruct")) == 0) 
  setClass("RSWIGStruct", representation("VIRTUAL"))



if(length(getClassDef("ExternalReference")) == 0) 
# Should be virtual but this means it loses its slots currently
#representation("VIRTUAL")
  setClass("ExternalReference", representation( ref = "externalptr"))



if(length(getClassDef("NativeRoutinePointer")) == 0) 
  setClass("NativeRoutinePointer", 
              representation(parameterTypes = "character",
                             returnType = "character",
                             "VIRTUAL"), 
              contains = "ExternalReference")

if(length(getClassDef("CRoutinePointer")) == 0) 
  setClass("CRoutinePointer", contains = "NativeRoutinePointer")


if(length(getClassDef("EnumerationValue")) == 0) 
  setClass("EnumerationValue", contains = "integer")


if(!isGeneric("copyToR")) 
 setGeneric("copyToR",
            function(value, obj = new(gsub("Ref$", "", class(value)))) 
               standardGeneric("copyToR"
           ))

setGeneric("delete", function(obj) standardGeneric("delete"))


SWIG_createNewRef = 
function(className, ..., append = TRUE)
{
  f = get(paste("new", className, sep = "_"), mode = "function")

  f(...)
}

if(!isGeneric("copyToC")) 
 setGeneric("copyToC", 
             function(value, obj = RSWIG_createNewRef(class(value)))
              standardGeneric("copyToC"
            ))


# 
defineEnumeration =
function(name, .values, where = topenv(parent.frame()), suffix = "Value")
{
   # Mirror the class definitions via the E analogous to .__C__
  defName = paste(".__E__", name, sep = "")
  assign(defName,  .values,  envir = where)

  if(nchar(suffix))
    name = paste(name, suffix, sep = "")

  setClass(name, contains = "EnumerationValue", where = where)
}

enumToInteger <- function(name,type)
{
   if (is.character(name)) {
   ans <- as.integer(get(paste(".__E__", type, sep = ""))[name])
   if (is.na(ans)) {warning("enum not found ", name, " ", type)}
   ans
   } 
}

enumFromInteger =
function(i,type)
{
  itemlist <- get(paste(".__E__", type, sep=""))
  names(itemlist)[match(i, itemlist)]
}

coerceIfNotSubclass =
function(obj, type) 
{
    if(!is(obj, type)) {as(obj, type)} else obj
}


setClass("SWIGArray", representation(dims = "integer"), contains = "ExternalReference")

setMethod("length", "SWIGArray", function(x) x@dims[1])


defineEnumeration("SCopyReferences",
                   .values = c( "FALSE" = 0, "TRUE" = 1, "DEEP" = 2))

assert = 
function(condition, message = "")
{
  if(!condition)
    stop(message)

  TRUE
}


if(FALSE) {
print.SWIGFunction =
function(x, ...)
 {
 }
}


#######################################################################

R_SWIG_getCallbackFunctionStack =
function()
{
    # No PACKAGE argument as we don't know what the DLL is.
  .Call("R_SWIG_debug_getCallbackFunctionData")
}

R_SWIG_addCallbackFunctionStack =
function(fun, userData = NULL)
{
    # No PACKAGE argument as we don't know what the DLL is.
  .Call("R_SWIG_R_pushCallbackFunctionData", fun, userData)
}


#######################################################################


setClass('C++Reference', contains = 'ExternalReference')
setClass('_p_std__vectorT_double_std__allocatorT_double_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', contains = 'C++Reference')
setClass('_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t', contains = 'C++Reference')
setClass('_p_CoolProp__SimpleState', contains = 'ExternalReference')
setClass("CoolProp::SimpleState",
    representation(
        rhomolar = "numeric",
        T = "numeric",
        p = "numeric",
        hmolar = "numeric",
        smolar = "numeric",
        umolar = "numeric",
        Q = "numeric"),
        contains = "RSWIGStruct")


# End class CoolProp::SimpleState

setClass('_p_CoolProp__CriticalState', contains = 'ExternalReference')
setClass("CoolProp::CriticalState",
    representation(
        stable = "logical"),
        contains = "RSWIGStruct")


# End class CoolProp::CriticalState

setClass('_p_CoolProp__SsatSimpleState', contains = 'ExternalReference')
setClass("CoolProp::SsatSimpleState",
    representation(
        exists = "character"),
        contains = "RSWIGStruct")


# End class CoolProp::SsatSimpleState

setClass('_p_CoolProp__SpinodalData', contains = 'C++Reference')
setClass('_p_CoolProp__GuessesStructure', contains = 'C++Reference')
setClass('_p_CoolProp__AbstractState', contains = 'C++Reference')
setClass('_p_CoolProp__PhaseEnvelopeData', contains = 'C++Reference')
setClass('_p_CoolProp__ConfigurationItem', contains = 'C++Reference')
setClass('_p_CoolProp__Configuration', contains = 'C++Reference')



setMethod('[', "ExternalReference",
function(x,i,j, ..., drop=TRUE) 
if (!is.null(x$"__getitem__")) 
sapply(i, function(n) x$"__getitem__"(i=as.integer(n-1))))

setMethod('[<-' , "ExternalReference",
function(x,i,j, ..., value) 
if (!is.null(x$"__setitem__")) {
sapply(1:length(i), function(n) 
x$"__setitem__"(i=as.integer(i[n]-1), x=value[n]))
x
})

setAs('ExternalReference', 'character',
function(from) {if (!is.null(from$"__str__")) from$"__str__"()})

setMethod('print', 'ExternalReference',
function(x) {print(as(x, "character"))})

# Start of DoubleVector___nonzero__

`DoubleVector___nonzero__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_DoubleVector___nonzero__', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`DoubleVector___nonzero__`, 'returnType') = 'logical'
attr(`DoubleVector___nonzero__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector___nonzero__`) = c("SWIGFunction", class('DoubleVector___nonzero__'))

# Start of DoubleVector___len__

`DoubleVector___len__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_DoubleVector___len__', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`DoubleVector___len__`, 'returnType') = 'integer'
attr(`DoubleVector___len__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector___len__`) = c("SWIGFunction", class('DoubleVector___len__'))

# Start of DoubleVector_pop

`DoubleVector_pop` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_DoubleVector_pop', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`DoubleVector_pop`, 'returnType') = 'numeric'
attr(`DoubleVector_pop`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector_pop`) = c("SWIGFunction", class('DoubleVector_pop'))

# Start of DoubleVector___getslice__

`DoubleVector___getslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_DoubleVector___getslice__', self, i, j, PACKAGE='CoolProp');
  
}

attr(`DoubleVector___getslice__`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`DoubleVector___getslice__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'integer')
class(`DoubleVector___getslice__`) = c("SWIGFunction", class('DoubleVector___getslice__'))

# Start of DoubleVector___setslice__

`DoubleVector___setslice__` = function(self, i, j, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  
  ;.Call('R_swig_DoubleVector___setslice__', self, i, j, v, PACKAGE='CoolProp');
  
}

attr(`DoubleVector___setslice__`, 'returnType') = 'void'
attr(`DoubleVector___setslice__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'integer', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector___setslice__`) = c("SWIGFunction", class('DoubleVector___setslice__'))

# Start of DoubleVector___delslice__

`DoubleVector___delslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_DoubleVector___delslice__', self, i, j, PACKAGE='CoolProp');
  
}

attr(`DoubleVector___delslice__`, 'returnType') = 'void'
attr(`DoubleVector___delslice__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'integer')
class(`DoubleVector___delslice__`) = c("SWIGFunction", class('DoubleVector___delslice__'))

# Start of DoubleVector___delitem__

`DoubleVector___delitem__` = function(self, i)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_DoubleVector___delitem__', self, i, PACKAGE='CoolProp');
  
}

attr(`DoubleVector___delitem__`, 'returnType') = 'void'
attr(`DoubleVector___delitem__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer')
class(`DoubleVector___delitem__`) = c("SWIGFunction", class('DoubleVector___delitem__'))

# Start of DoubleVector___getitem__

`DoubleVector___getitem__` = function(self, i, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_DoubleVector___getitem__', self, i, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`DoubleVector___getitem__`, 'returnType') = 'numeric'
attr(`DoubleVector___getitem__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer')
class(`DoubleVector___getitem__`) = c("SWIGFunction", class('DoubleVector___getitem__'))

# Start of DoubleVector___setitem__

`DoubleVector___setitem__` = function(self, i, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  ;.Call('R_swig_DoubleVector___setitem__', self, i, x, PACKAGE='CoolProp');
  
}

attr(`DoubleVector___setitem__`, 'returnType') = 'void'
attr(`DoubleVector___setitem__`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'numeric')
class(`DoubleVector___setitem__`) = c("SWIGFunction", class('DoubleVector___setitem__'))

# Start of DoubleVector_append

`DoubleVector_append` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_DoubleVector_append', self, x, PACKAGE='CoolProp');
  
}

attr(`DoubleVector_append`, 'returnType') = 'void'
attr(`DoubleVector_append`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'numeric')
class(`DoubleVector_append`) = c("SWIGFunction", class('DoubleVector_append'))

# Start of new_DoubleVector

`DoubleVector__SWIG_0` = function()
{
  ;.Call('R_swig_new_DoubleVector__SWIG_0', PACKAGE='CoolProp');
  
}

attr(`DoubleVector__SWIG_0`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
class(`DoubleVector__SWIG_0`) = c("SWIGFunction", class('DoubleVector__SWIG_0'))

# Start of new_DoubleVector

`DoubleVector__SWIG_1` = function(s_arg1)
{
  ;.Call('R_swig_new_DoubleVector__SWIG_1', s_arg1, PACKAGE='CoolProp');
  
}

attr(`DoubleVector__SWIG_1`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`DoubleVector__SWIG_1`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector__SWIG_1`) = c("SWIGFunction", class('DoubleVector__SWIG_1'))

# Start of DoubleVector_empty

`DoubleVector_empty` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_DoubleVector_empty', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`DoubleVector_empty`, 'returnType') = 'logical'
attr(`DoubleVector_empty`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector_empty`) = c("SWIGFunction", class('DoubleVector_empty'))

# Start of DoubleVector_size

`DoubleVector_size` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_DoubleVector_size', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`DoubleVector_size`, 'returnType') = 'integer'
attr(`DoubleVector_size`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector_size`) = c("SWIGFunction", class('DoubleVector_size'))

# Start of DoubleVector_clear

`DoubleVector_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_DoubleVector_clear', self, PACKAGE='CoolProp');
  
}

attr(`DoubleVector_clear`, 'returnType') = 'void'
attr(`DoubleVector_clear`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector_clear`) = c("SWIGFunction", class('DoubleVector_clear'))

# Start of DoubleVector_swap

`DoubleVector_swap` = function(self, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_DoubleVector_swap', self, v, PACKAGE='CoolProp');
  
}

attr(`DoubleVector_swap`, 'returnType') = 'void'
attr(`DoubleVector_swap`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector_swap`) = c("SWIGFunction", class('DoubleVector_swap'))

# Start of DoubleVector_get_allocator

`DoubleVector_get_allocator` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_DoubleVector_get_allocator', self, as.logical(.copy), PACKAGE='CoolProp');
  ans <- new("_p_std__allocatorT_double_t", ref=ans);
  
  ans
  
}

attr(`DoubleVector_get_allocator`, 'returnType') = '_p_std__allocatorT_double_t'
attr(`DoubleVector_get_allocator`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector_get_allocator`) = c("SWIGFunction", class('DoubleVector_get_allocator'))

# Start of new_DoubleVector

`DoubleVector__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;.Call('R_swig_new_DoubleVector__SWIG_2', size, PACKAGE='CoolProp');
  
}

attr(`DoubleVector__SWIG_2`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`DoubleVector__SWIG_2`, "inputTypes") = c('integer')
class(`DoubleVector__SWIG_2`) = c("SWIGFunction", class('DoubleVector__SWIG_2'))

# Start of DoubleVector_pop_back

`DoubleVector_pop_back` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_DoubleVector_pop_back', self, PACKAGE='CoolProp');
  
}

attr(`DoubleVector_pop_back`, 'returnType') = 'void'
attr(`DoubleVector_pop_back`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector_pop_back`) = c("SWIGFunction", class('DoubleVector_pop_back'))

# Start of DoubleVector_resize

`DoubleVector_resize__SWIG_0` = function(self, new_size)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_DoubleVector_resize__SWIG_0', self, new_size, PACKAGE='CoolProp');
  
}

attr(`DoubleVector_resize__SWIG_0`, 'returnType') = 'void'
attr(`DoubleVector_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer')
class(`DoubleVector_resize__SWIG_0`) = c("SWIGFunction", class('DoubleVector_resize__SWIG_0'))

# Start of new_DoubleVector

`DoubleVector__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  
  ;.Call('R_swig_new_DoubleVector__SWIG_3', size, value, PACKAGE='CoolProp');
  
}

attr(`DoubleVector__SWIG_3`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`DoubleVector__SWIG_3`, "inputTypes") = c('integer', 'numeric')
class(`DoubleVector__SWIG_3`) = c("SWIGFunction", class('DoubleVector__SWIG_3'))

`DoubleVector` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- DoubleVector__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- DoubleVector__SWIG_2; 
    }
    else if (( is.numeric(argv[[1]]) )) {
      f <- DoubleVector__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && is.numeric(argv[[2]]) && length(argv[[2]]) == 1) {
      f <- DoubleVector__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for DoubleVector with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of DoubleVector_push_back

`DoubleVector_push_back` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_DoubleVector_push_back', self, x, PACKAGE='CoolProp');
  
}

attr(`DoubleVector_push_back`, 'returnType') = 'void'
attr(`DoubleVector_push_back`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'numeric')
class(`DoubleVector_push_back`) = c("SWIGFunction", class('DoubleVector_push_back'))

# Start of DoubleVector_front

`DoubleVector_front` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_DoubleVector_front', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`DoubleVector_front`, 'returnType') = 'numeric'
attr(`DoubleVector_front`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector_front`) = c("SWIGFunction", class('DoubleVector_front'))

# Start of DoubleVector_back

`DoubleVector_back` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_DoubleVector_back', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`DoubleVector_back`, 'returnType') = 'numeric'
attr(`DoubleVector_back`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector_back`) = c("SWIGFunction", class('DoubleVector_back'))

# Start of DoubleVector_assign

`DoubleVector_assign` = function(self, n, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  ;.Call('R_swig_DoubleVector_assign', self, n, x, PACKAGE='CoolProp');
  
}

attr(`DoubleVector_assign`, 'returnType') = 'void'
attr(`DoubleVector_assign`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'numeric')
class(`DoubleVector_assign`) = c("SWIGFunction", class('DoubleVector_assign'))

# Start of DoubleVector_resize

`DoubleVector_resize__SWIG_1` = function(self, new_size, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  
  ;.Call('R_swig_DoubleVector_resize__SWIG_1', self, new_size, x, PACKAGE='CoolProp');
  
}

attr(`DoubleVector_resize__SWIG_1`, 'returnType') = 'void'
attr(`DoubleVector_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer', 'numeric')
class(`DoubleVector_resize__SWIG_1`) = c("SWIGFunction", class('DoubleVector_resize__SWIG_1'))

`DoubleVector_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_std__vectorT_double_std__allocatorT_double_t_t') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- DoubleVector_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_double_std__allocatorT_double_t_t') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && is.numeric(argv[[3]]) && length(argv[[3]]) == 1) {
      f <- DoubleVector_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for DoubleVector_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of DoubleVector_reserve

`DoubleVector_reserve` = function(self, n)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_DoubleVector_reserve', self, n, PACKAGE='CoolProp');
  
}

attr(`DoubleVector_reserve`, 'returnType') = 'void'
attr(`DoubleVector_reserve`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t', 'integer')
class(`DoubleVector_reserve`) = c("SWIGFunction", class('DoubleVector_reserve'))

# Start of DoubleVector_capacity

`DoubleVector_capacity` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_DoubleVector_capacity', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`DoubleVector_capacity`, 'returnType') = 'integer'
attr(`DoubleVector_capacity`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`DoubleVector_capacity`) = c("SWIGFunction", class('DoubleVector_capacity'))

# Start of delete_DoubleVector

`delete_DoubleVector` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_DoubleVector', self, PACKAGE='CoolProp');
  
}

attr(`delete_DoubleVector`, 'returnType') = 'void'
attr(`delete_DoubleVector`, "inputTypes") = c('_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`delete_DoubleVector`) = c("SWIGFunction", class('delete_DoubleVector'))

# Start of accessor method for std::vector<(double)>
setMethod('$', '_p_std__vectorT_double_std__allocatorT_double_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = DoubleVector___nonzero__, '__len__' = DoubleVector___len__, 'pop' = DoubleVector_pop, '__getslice__' = DoubleVector___getslice__, '__setslice__' = DoubleVector___setslice__, '__delslice__' = DoubleVector___delslice__, '__delitem__' = DoubleVector___delitem__, '__getitem__' = DoubleVector___getitem__, '__setitem__' = DoubleVector___setitem__, 'append' = DoubleVector_append, 'empty' = DoubleVector_empty, 'size' = DoubleVector_size, 'clear' = DoubleVector_clear, 'swap' = DoubleVector_swap, 'get_allocator' = DoubleVector_get_allocator, 'pop_back' = DoubleVector_pop_back, 'resize' = DoubleVector_resize, 'push_back' = DoubleVector_push_back, 'front' = DoubleVector_front, 'back' = DoubleVector_back, 'assign' = DoubleVector_assign, 'reserve' = DoubleVector_reserve, 'capacity' = DoubleVector_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(double)>
setMethod('delete', '_p_std__vectorT_double_std__allocatorT_double_t_t', function(obj) {delete_std__vectorT_double_std__allocatorT_double_t_t(obj)})
# Start of VectorOfDoubleVector___nonzero__

`VectorOfDoubleVector___nonzero__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VectorOfDoubleVector___nonzero__', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`VectorOfDoubleVector___nonzero__`, 'returnType') = 'logical'
attr(`VectorOfDoubleVector___nonzero__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t')
class(`VectorOfDoubleVector___nonzero__`) = c("SWIGFunction", class('VectorOfDoubleVector___nonzero__'))

# Start of VectorOfDoubleVector___len__

`VectorOfDoubleVector___len__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VectorOfDoubleVector___len__', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`VectorOfDoubleVector___len__`, 'returnType') = 'integer'
attr(`VectorOfDoubleVector___len__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t')
class(`VectorOfDoubleVector___len__`) = c("SWIGFunction", class('VectorOfDoubleVector___len__'))

# Start of VectorOfDoubleVector_pop

`VectorOfDoubleVector_pop` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VectorOfDoubleVector_pop', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`VectorOfDoubleVector_pop`, 'returnType') = 'numeric'
attr(`VectorOfDoubleVector_pop`, "inputTypes") = c('_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t')
class(`VectorOfDoubleVector_pop`) = c("SWIGFunction", class('VectorOfDoubleVector_pop'))

# Start of VectorOfDoubleVector___getslice__

`VectorOfDoubleVector___getslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VectorOfDoubleVector___getslice__', self, i, j, PACKAGE='CoolProp');
  
}

attr(`VectorOfDoubleVector___getslice__`, 'returnType') = '_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t'
attr(`VectorOfDoubleVector___getslice__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t', 'integer', 'integer')
class(`VectorOfDoubleVector___getslice__`) = c("SWIGFunction", class('VectorOfDoubleVector___getslice__'))

# Start of VectorOfDoubleVector___setslice__

`VectorOfDoubleVector___setslice__` = function(self, i, j, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  v = lapply(v, as.numeric);
  ;.Call('R_swig_VectorOfDoubleVector___setslice__', self, i, j, v, PACKAGE='CoolProp');
  
}

attr(`VectorOfDoubleVector___setslice__`, 'returnType') = 'void'
attr(`VectorOfDoubleVector___setslice__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t', 'integer', 'integer', '_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t')
class(`VectorOfDoubleVector___setslice__`) = c("SWIGFunction", class('VectorOfDoubleVector___setslice__'))

# Start of VectorOfDoubleVector___delslice__

`VectorOfDoubleVector___delslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VectorOfDoubleVector___delslice__', self, i, j, PACKAGE='CoolProp');
  
}

attr(`VectorOfDoubleVector___delslice__`, 'returnType') = 'void'
attr(`VectorOfDoubleVector___delslice__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t', 'integer', 'integer')
class(`VectorOfDoubleVector___delslice__`) = c("SWIGFunction", class('VectorOfDoubleVector___delslice__'))

# Start of VectorOfDoubleVector___delitem__

`VectorOfDoubleVector___delitem__` = function(self, i)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VectorOfDoubleVector___delitem__', self, i, PACKAGE='CoolProp');
  
}

attr(`VectorOfDoubleVector___delitem__`, 'returnType') = 'void'
attr(`VectorOfDoubleVector___delitem__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t', 'integer')
class(`VectorOfDoubleVector___delitem__`) = c("SWIGFunction", class('VectorOfDoubleVector___delitem__'))

# Start of VectorOfDoubleVector___getitem__

`VectorOfDoubleVector___getitem__` = function(self, i, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VectorOfDoubleVector___getitem__', self, i, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`VectorOfDoubleVector___getitem__`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`VectorOfDoubleVector___getitem__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t', 'integer')
class(`VectorOfDoubleVector___getitem__`) = c("SWIGFunction", class('VectorOfDoubleVector___getitem__'))

# Start of VectorOfDoubleVector___setitem__

`VectorOfDoubleVector___setitem__` = function(self, i, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  
  ;.Call('R_swig_VectorOfDoubleVector___setitem__', self, i, x, PACKAGE='CoolProp');
  
}

attr(`VectorOfDoubleVector___setitem__`, 'returnType') = 'void'
attr(`VectorOfDoubleVector___setitem__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t', 'integer', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VectorOfDoubleVector___setitem__`) = c("SWIGFunction", class('VectorOfDoubleVector___setitem__'))

# Start of VectorOfDoubleVector_append

`VectorOfDoubleVector_append` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_VectorOfDoubleVector_append', self, x, PACKAGE='CoolProp');
  
}

attr(`VectorOfDoubleVector_append`, 'returnType') = 'void'
attr(`VectorOfDoubleVector_append`, "inputTypes") = c('_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VectorOfDoubleVector_append`) = c("SWIGFunction", class('VectorOfDoubleVector_append'))

# Start of new_VectorOfDoubleVector

`VectorOfDoubleVector__SWIG_0` = function()
{
  ;.Call('R_swig_new_VectorOfDoubleVector__SWIG_0', PACKAGE='CoolProp');
  
}

attr(`VectorOfDoubleVector__SWIG_0`, 'returnType') = '_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t'
class(`VectorOfDoubleVector__SWIG_0`) = c("SWIGFunction", class('VectorOfDoubleVector__SWIG_0'))

# Start of new_VectorOfDoubleVector

`VectorOfDoubleVector__SWIG_1` = function(s_arg1)
{
  s_arg1 = lapply(s_arg1, as.numeric);
  ;.Call('R_swig_new_VectorOfDoubleVector__SWIG_1', s_arg1, PACKAGE='CoolProp');
  
}

attr(`VectorOfDoubleVector__SWIG_1`, 'returnType') = '_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t'
attr(`VectorOfDoubleVector__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t')
class(`VectorOfDoubleVector__SWIG_1`) = c("SWIGFunction", class('VectorOfDoubleVector__SWIG_1'))

# Start of VectorOfDoubleVector_empty

`VectorOfDoubleVector_empty` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VectorOfDoubleVector_empty', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`VectorOfDoubleVector_empty`, 'returnType') = 'logical'
attr(`VectorOfDoubleVector_empty`, "inputTypes") = c('_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t')
class(`VectorOfDoubleVector_empty`) = c("SWIGFunction", class('VectorOfDoubleVector_empty'))

# Start of VectorOfDoubleVector_size

`VectorOfDoubleVector_size` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VectorOfDoubleVector_size', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`VectorOfDoubleVector_size`, 'returnType') = 'integer'
attr(`VectorOfDoubleVector_size`, "inputTypes") = c('_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t')
class(`VectorOfDoubleVector_size`) = c("SWIGFunction", class('VectorOfDoubleVector_size'))

# Start of VectorOfDoubleVector_clear

`VectorOfDoubleVector_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VectorOfDoubleVector_clear', self, PACKAGE='CoolProp');
  
}

attr(`VectorOfDoubleVector_clear`, 'returnType') = 'void'
attr(`VectorOfDoubleVector_clear`, "inputTypes") = c('_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t')
class(`VectorOfDoubleVector_clear`) = c("SWIGFunction", class('VectorOfDoubleVector_clear'))

# Start of VectorOfDoubleVector_swap

`VectorOfDoubleVector_swap` = function(self, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_VectorOfDoubleVector_swap', self, v, PACKAGE='CoolProp');
  
}

attr(`VectorOfDoubleVector_swap`, 'returnType') = 'void'
attr(`VectorOfDoubleVector_swap`, "inputTypes") = c('_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t', '_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t')
class(`VectorOfDoubleVector_swap`) = c("SWIGFunction", class('VectorOfDoubleVector_swap'))

# Start of VectorOfDoubleVector_get_allocator

`VectorOfDoubleVector_get_allocator` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_VectorOfDoubleVector_get_allocator', self, as.logical(.copy), PACKAGE='CoolProp');
  ans <- new("_p_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t", ref=ans);
  
  ans
  
}

attr(`VectorOfDoubleVector_get_allocator`, 'returnType') = '_p_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t'
attr(`VectorOfDoubleVector_get_allocator`, "inputTypes") = c('_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t')
class(`VectorOfDoubleVector_get_allocator`) = c("SWIGFunction", class('VectorOfDoubleVector_get_allocator'))

# Start of new_VectorOfDoubleVector

`VectorOfDoubleVector__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;.Call('R_swig_new_VectorOfDoubleVector__SWIG_2', size, PACKAGE='CoolProp');
  
}

attr(`VectorOfDoubleVector__SWIG_2`, 'returnType') = '_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t'
attr(`VectorOfDoubleVector__SWIG_2`, "inputTypes") = c('integer')
class(`VectorOfDoubleVector__SWIG_2`) = c("SWIGFunction", class('VectorOfDoubleVector__SWIG_2'))

# Start of VectorOfDoubleVector_pop_back

`VectorOfDoubleVector_pop_back` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VectorOfDoubleVector_pop_back', self, PACKAGE='CoolProp');
  
}

attr(`VectorOfDoubleVector_pop_back`, 'returnType') = 'void'
attr(`VectorOfDoubleVector_pop_back`, "inputTypes") = c('_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t')
class(`VectorOfDoubleVector_pop_back`) = c("SWIGFunction", class('VectorOfDoubleVector_pop_back'))

# Start of VectorOfDoubleVector_resize

`VectorOfDoubleVector_resize__SWIG_0` = function(self, new_size)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VectorOfDoubleVector_resize__SWIG_0', self, new_size, PACKAGE='CoolProp');
  
}

attr(`VectorOfDoubleVector_resize__SWIG_0`, 'returnType') = 'void'
attr(`VectorOfDoubleVector_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t', 'integer')
class(`VectorOfDoubleVector_resize__SWIG_0`) = c("SWIGFunction", class('VectorOfDoubleVector_resize__SWIG_0'))

# Start of new_VectorOfDoubleVector

`VectorOfDoubleVector__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  
  ;.Call('R_swig_new_VectorOfDoubleVector__SWIG_3', size, value, PACKAGE='CoolProp');
  
}

attr(`VectorOfDoubleVector__SWIG_3`, 'returnType') = '_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t'
attr(`VectorOfDoubleVector__SWIG_3`, "inputTypes") = c('integer', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VectorOfDoubleVector__SWIG_3`) = c("SWIGFunction", class('VectorOfDoubleVector__SWIG_3'))

`VectorOfDoubleVector` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VectorOfDoubleVector__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VectorOfDoubleVector__SWIG_2; 
    }
    else if (( is.list(argv[[1]]) && all(sapply(argv[[1]] , is.integer) || sapply(argv[[1]], is.numeric)) )) {
      f <- VectorOfDoubleVector__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && ( is.numeric(argv[[2]]) )) {
      f <- VectorOfDoubleVector__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VectorOfDoubleVector with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VectorOfDoubleVector_push_back

`VectorOfDoubleVector_push_back` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_VectorOfDoubleVector_push_back', self, x, PACKAGE='CoolProp');
  
}

attr(`VectorOfDoubleVector_push_back`, 'returnType') = 'void'
attr(`VectorOfDoubleVector_push_back`, "inputTypes") = c('_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VectorOfDoubleVector_push_back`) = c("SWIGFunction", class('VectorOfDoubleVector_push_back'))

# Start of VectorOfDoubleVector_front

`VectorOfDoubleVector_front` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VectorOfDoubleVector_front', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`VectorOfDoubleVector_front`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`VectorOfDoubleVector_front`, "inputTypes") = c('_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t')
class(`VectorOfDoubleVector_front`) = c("SWIGFunction", class('VectorOfDoubleVector_front'))

# Start of VectorOfDoubleVector_back

`VectorOfDoubleVector_back` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VectorOfDoubleVector_back', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`VectorOfDoubleVector_back`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`VectorOfDoubleVector_back`, "inputTypes") = c('_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t')
class(`VectorOfDoubleVector_back`) = c("SWIGFunction", class('VectorOfDoubleVector_back'))

# Start of VectorOfDoubleVector_assign

`VectorOfDoubleVector_assign` = function(self, n, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  
  ;.Call('R_swig_VectorOfDoubleVector_assign', self, n, x, PACKAGE='CoolProp');
  
}

attr(`VectorOfDoubleVector_assign`, 'returnType') = 'void'
attr(`VectorOfDoubleVector_assign`, "inputTypes") = c('_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t', 'integer', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VectorOfDoubleVector_assign`) = c("SWIGFunction", class('VectorOfDoubleVector_assign'))

# Start of VectorOfDoubleVector_resize

`VectorOfDoubleVector_resize__SWIG_1` = function(self, new_size, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  
  ;.Call('R_swig_VectorOfDoubleVector_resize__SWIG_1', self, new_size, x, PACKAGE='CoolProp');
  
}

attr(`VectorOfDoubleVector_resize__SWIG_1`, 'returnType') = 'void'
attr(`VectorOfDoubleVector_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t', 'integer', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`VectorOfDoubleVector_resize__SWIG_1`) = c("SWIGFunction", class('VectorOfDoubleVector_resize__SWIG_1'))

`VectorOfDoubleVector_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VectorOfDoubleVector_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( is.numeric(argv[[3]]) )) {
      f <- VectorOfDoubleVector_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VectorOfDoubleVector_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VectorOfDoubleVector_reserve

`VectorOfDoubleVector_reserve` = function(self, n)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VectorOfDoubleVector_reserve', self, n, PACKAGE='CoolProp');
  
}

attr(`VectorOfDoubleVector_reserve`, 'returnType') = 'void'
attr(`VectorOfDoubleVector_reserve`, "inputTypes") = c('_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t', 'integer')
class(`VectorOfDoubleVector_reserve`) = c("SWIGFunction", class('VectorOfDoubleVector_reserve'))

# Start of VectorOfDoubleVector_capacity

`VectorOfDoubleVector_capacity` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VectorOfDoubleVector_capacity', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`VectorOfDoubleVector_capacity`, 'returnType') = 'integer'
attr(`VectorOfDoubleVector_capacity`, "inputTypes") = c('_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t')
class(`VectorOfDoubleVector_capacity`) = c("SWIGFunction", class('VectorOfDoubleVector_capacity'))

# Start of delete_VectorOfDoubleVector

`delete_VectorOfDoubleVector` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_VectorOfDoubleVector', self, PACKAGE='CoolProp');
  
}

attr(`delete_VectorOfDoubleVector`, 'returnType') = 'void'
attr(`delete_VectorOfDoubleVector`, "inputTypes") = c('_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t')
class(`delete_VectorOfDoubleVector`) = c("SWIGFunction", class('delete_VectorOfDoubleVector'))

# Start of accessor method for std::vector<(std::vector<(double)>)>
setMethod('$', '_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VectorOfDoubleVector___nonzero__, '__len__' = VectorOfDoubleVector___len__, 'pop' = VectorOfDoubleVector_pop, '__getslice__' = VectorOfDoubleVector___getslice__, '__setslice__' = VectorOfDoubleVector___setslice__, '__delslice__' = VectorOfDoubleVector___delslice__, '__delitem__' = VectorOfDoubleVector___delitem__, '__getitem__' = VectorOfDoubleVector___getitem__, '__setitem__' = VectorOfDoubleVector___setitem__, 'append' = VectorOfDoubleVector_append, 'empty' = VectorOfDoubleVector_empty, 'size' = VectorOfDoubleVector_size, 'clear' = VectorOfDoubleVector_clear, 'swap' = VectorOfDoubleVector_swap, 'get_allocator' = VectorOfDoubleVector_get_allocator, 'pop_back' = VectorOfDoubleVector_pop_back, 'resize' = VectorOfDoubleVector_resize, 'push_back' = VectorOfDoubleVector_push_back, 'front' = VectorOfDoubleVector_front, 'back' = VectorOfDoubleVector_back, 'assign' = VectorOfDoubleVector_assign, 'reserve' = VectorOfDoubleVector_reserve, 'capacity' = VectorOfDoubleVector_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(std::vector<(double)>)>
setMethod('delete', '_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t', function(obj) {delete_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t(obj)})
# Start of StringVector___nonzero__

`StringVector___nonzero__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_StringVector___nonzero__', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`StringVector___nonzero__`, 'returnType') = 'logical'
attr(`StringVector___nonzero__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector___nonzero__`) = c("SWIGFunction", class('StringVector___nonzero__'))

# Start of StringVector___len__

`StringVector___len__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_StringVector___len__', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`StringVector___len__`, 'returnType') = 'integer'
attr(`StringVector___len__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector___len__`) = c("SWIGFunction", class('StringVector___len__'))

# Start of StringVector_pop

`StringVector_pop` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_StringVector_pop', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`StringVector_pop`, 'returnType') = 'character'
attr(`StringVector_pop`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector_pop`) = c("SWIGFunction", class('StringVector_pop'))

# Start of StringVector___getslice__

`StringVector___getslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_StringVector___getslice__', self, i, j, PACKAGE='CoolProp');
  ans <- new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans) ;
  
  ans
  
}

attr(`StringVector___getslice__`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`StringVector___getslice__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'integer')
class(`StringVector___getslice__`) = c("SWIGFunction", class('StringVector___getslice__'))

# Start of StringVector___setslice__

`StringVector___setslice__` = function(self, i, j, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_StringVector___setslice__', self, i, j, v, PACKAGE='CoolProp');
  
}

attr(`StringVector___setslice__`, 'returnType') = 'void'
attr(`StringVector___setslice__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'integer', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector___setslice__`) = c("SWIGFunction", class('StringVector___setslice__'))

# Start of StringVector___delslice__

`StringVector___delslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_StringVector___delslice__', self, i, j, PACKAGE='CoolProp');
  
}

attr(`StringVector___delslice__`, 'returnType') = 'void'
attr(`StringVector___delslice__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'integer')
class(`StringVector___delslice__`) = c("SWIGFunction", class('StringVector___delslice__'))

# Start of StringVector___delitem__

`StringVector___delitem__` = function(self, i)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_StringVector___delitem__', self, i, PACKAGE='CoolProp');
  
}

attr(`StringVector___delitem__`, 'returnType') = 'void'
attr(`StringVector___delitem__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer')
class(`StringVector___delitem__`) = c("SWIGFunction", class('StringVector___delitem__'))

# Start of StringVector___getitem__

`StringVector___getitem__` = function(self, i, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_StringVector___getitem__', self, i, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`StringVector___getitem__`, 'returnType') = 'character'
attr(`StringVector___getitem__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer')
class(`StringVector___getitem__`) = c("SWIGFunction", class('StringVector___getitem__'))

# Start of StringVector___setitem__

`StringVector___setitem__` = function(self, i, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  x = as(x, "character"); 
  ;.Call('R_swig_StringVector___setitem__', self, i, x, PACKAGE='CoolProp');
  
}

attr(`StringVector___setitem__`, 'returnType') = 'void'
attr(`StringVector___setitem__`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'character')
class(`StringVector___setitem__`) = c("SWIGFunction", class('StringVector___setitem__'))

# Start of StringVector_append

`StringVector_append` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  x = as(x, "character"); 
  ;.Call('R_swig_StringVector_append', self, x, PACKAGE='CoolProp');
  
}

attr(`StringVector_append`, 'returnType') = 'void'
attr(`StringVector_append`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'character')
class(`StringVector_append`) = c("SWIGFunction", class('StringVector_append'))

# Start of new_StringVector

`StringVector__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_StringVector__SWIG_0', PACKAGE='CoolProp');
  ans <- new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_StringVector)
  ans
  
}

attr(`StringVector__SWIG_0`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
class(`StringVector__SWIG_0`) = c("SWIGFunction", class('StringVector__SWIG_0'))

# Start of new_StringVector

`StringVector__SWIG_1` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_new_StringVector__SWIG_1', s_arg1, PACKAGE='CoolProp');
  ans <- new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_StringVector)
  ans
  
}

attr(`StringVector__SWIG_1`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`StringVector__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector__SWIG_1`) = c("SWIGFunction", class('StringVector__SWIG_1'))

# Start of StringVector_empty

`StringVector_empty` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_StringVector_empty', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`StringVector_empty`, 'returnType') = 'logical'
attr(`StringVector_empty`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector_empty`) = c("SWIGFunction", class('StringVector_empty'))

# Start of StringVector_size

`StringVector_size` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_StringVector_size', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`StringVector_size`, 'returnType') = 'integer'
attr(`StringVector_size`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector_size`) = c("SWIGFunction", class('StringVector_size'))

# Start of StringVector_clear

`StringVector_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_StringVector_clear', self, PACKAGE='CoolProp');
  
}

attr(`StringVector_clear`, 'returnType') = 'void'
attr(`StringVector_clear`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector_clear`) = c("SWIGFunction", class('StringVector_clear'))

# Start of StringVector_swap

`StringVector_swap` = function(self, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_StringVector_swap', self, v, PACKAGE='CoolProp');
  
}

attr(`StringVector_swap`, 'returnType') = 'void'
attr(`StringVector_swap`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector_swap`) = c("SWIGFunction", class('StringVector_swap'))

# Start of StringVector_get_allocator

`StringVector_get_allocator` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_StringVector_get_allocator', self, as.logical(.copy), PACKAGE='CoolProp');
  ans <- new("_p_std__allocatorT_std__string_t", ref=ans);
  
  ans
  
}

attr(`StringVector_get_allocator`, 'returnType') = '_p_std__allocatorT_std__string_t'
attr(`StringVector_get_allocator`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector_get_allocator`) = c("SWIGFunction", class('StringVector_get_allocator'))

# Start of new_StringVector

`StringVector__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_StringVector__SWIG_2', size, PACKAGE='CoolProp');
  ans <- new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_StringVector)
  ans
  
}

attr(`StringVector__SWIG_2`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`StringVector__SWIG_2`, "inputTypes") = c('integer')
class(`StringVector__SWIG_2`) = c("SWIGFunction", class('StringVector__SWIG_2'))

# Start of StringVector_pop_back

`StringVector_pop_back` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_StringVector_pop_back', self, PACKAGE='CoolProp');
  
}

attr(`StringVector_pop_back`, 'returnType') = 'void'
attr(`StringVector_pop_back`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector_pop_back`) = c("SWIGFunction", class('StringVector_pop_back'))

# Start of StringVector_resize

`StringVector_resize__SWIG_0` = function(self, new_size)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_StringVector_resize__SWIG_0', self, new_size, PACKAGE='CoolProp');
  
}

attr(`StringVector_resize__SWIG_0`, 'returnType') = 'void'
attr(`StringVector_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer')
class(`StringVector_resize__SWIG_0`) = c("SWIGFunction", class('StringVector_resize__SWIG_0'))

# Start of new_StringVector

`StringVector__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  value = as(value, "character"); 
  ;ans = .Call('R_swig_new_StringVector__SWIG_3', size, value, PACKAGE='CoolProp');
  ans <- new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_StringVector)
  ans
  
}

attr(`StringVector__SWIG_3`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`StringVector__SWIG_3`, "inputTypes") = c('integer', 'character')
class(`StringVector__SWIG_3`) = c("SWIGFunction", class('StringVector__SWIG_3'))

`StringVector` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- StringVector__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- StringVector__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t') && length(argv[[1]]) == 1) {
      f <- StringVector__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && is.character(argv[[2]]) && length(argv[[2]]) == 1) {
      f <- StringVector__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for StringVector with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of StringVector_push_back

`StringVector_push_back` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  x = as(x, "character"); 
  ;.Call('R_swig_StringVector_push_back', self, x, PACKAGE='CoolProp');
  
}

attr(`StringVector_push_back`, 'returnType') = 'void'
attr(`StringVector_push_back`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'character')
class(`StringVector_push_back`) = c("SWIGFunction", class('StringVector_push_back'))

# Start of StringVector_front

`StringVector_front` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_StringVector_front', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`StringVector_front`, 'returnType') = 'character'
attr(`StringVector_front`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector_front`) = c("SWIGFunction", class('StringVector_front'))

# Start of StringVector_back

`StringVector_back` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_StringVector_back', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`StringVector_back`, 'returnType') = 'character'
attr(`StringVector_back`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector_back`) = c("SWIGFunction", class('StringVector_back'))

# Start of StringVector_assign

`StringVector_assign` = function(self, n, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  x = as(x, "character"); 
  ;.Call('R_swig_StringVector_assign', self, n, x, PACKAGE='CoolProp');
  
}

attr(`StringVector_assign`, 'returnType') = 'void'
attr(`StringVector_assign`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'character')
class(`StringVector_assign`) = c("SWIGFunction", class('StringVector_assign'))

# Start of StringVector_resize

`StringVector_resize__SWIG_1` = function(self, new_size, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  x = as(x, "character"); 
  ;.Call('R_swig_StringVector_resize__SWIG_1', self, new_size, x, PACKAGE='CoolProp');
  
}

attr(`StringVector_resize__SWIG_1`, 'returnType') = 'void'
attr(`StringVector_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer', 'character')
class(`StringVector_resize__SWIG_1`) = c("SWIGFunction", class('StringVector_resize__SWIG_1'))

`StringVector_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- StringVector_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && is.character(argv[[3]]) && length(argv[[3]]) == 1) {
      f <- StringVector_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for StringVector_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of StringVector_reserve

`StringVector_reserve` = function(self, n)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_StringVector_reserve', self, n, PACKAGE='CoolProp');
  
}

attr(`StringVector_reserve`, 'returnType') = 'void'
attr(`StringVector_reserve`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'integer')
class(`StringVector_reserve`) = c("SWIGFunction", class('StringVector_reserve'))

# Start of StringVector_capacity

`StringVector_capacity` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_StringVector_capacity', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`StringVector_capacity`, 'returnType') = 'integer'
attr(`StringVector_capacity`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`StringVector_capacity`) = c("SWIGFunction", class('StringVector_capacity'))

# Start of delete_StringVector

`delete_StringVector` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_StringVector', self, PACKAGE='CoolProp');
  
}

attr(`delete_StringVector`, 'returnType') = 'void'
attr(`delete_StringVector`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`delete_StringVector`) = c("SWIGFunction", class('delete_StringVector'))

# Start of accessor method for std::vector<(std::string)>
setMethod('$', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = StringVector___nonzero__, '__len__' = StringVector___len__, 'pop' = StringVector_pop, '__getslice__' = StringVector___getslice__, '__setslice__' = StringVector___setslice__, '__delslice__' = StringVector___delslice__, '__delitem__' = StringVector___delitem__, '__getitem__' = StringVector___getitem__, '__setitem__' = StringVector___setitem__, 'append' = StringVector_append, 'empty' = StringVector_empty, 'size' = StringVector_size, 'clear' = StringVector_clear, 'swap' = StringVector_swap, 'get_allocator' = StringVector_get_allocator, 'pop_back' = StringVector_pop_back, 'resize' = StringVector_resize, 'push_back' = StringVector_push_back, 'front' = StringVector_front, 'back' = StringVector_back, 'assign' = StringVector_assign, 'reserve' = StringVector_reserve, 'capacity' = StringVector_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(std::string)>
setMethod('delete', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', function(obj) {delete_std__vectorT_std__string_std__allocatorT_std__string_t_t(obj)})
# Start of VectorOfStringVector___nonzero__

`VectorOfStringVector___nonzero__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VectorOfStringVector___nonzero__', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`VectorOfStringVector___nonzero__`, 'returnType') = 'logical'
attr(`VectorOfStringVector___nonzero__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t')
class(`VectorOfStringVector___nonzero__`) = c("SWIGFunction", class('VectorOfStringVector___nonzero__'))

# Start of VectorOfStringVector___len__

`VectorOfStringVector___len__` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VectorOfStringVector___len__', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`VectorOfStringVector___len__`, 'returnType') = 'integer'
attr(`VectorOfStringVector___len__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t')
class(`VectorOfStringVector___len__`) = c("SWIGFunction", class('VectorOfStringVector___len__'))

# Start of VectorOfStringVector_pop

`VectorOfStringVector_pop` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_VectorOfStringVector_pop', self, as.logical(.copy), PACKAGE='CoolProp');
  ans <- new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans);
  
  ans
  
}

attr(`VectorOfStringVector_pop`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`VectorOfStringVector_pop`, "inputTypes") = c('_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t')
class(`VectorOfStringVector_pop`) = c("SWIGFunction", class('VectorOfStringVector_pop'))

# Start of VectorOfStringVector___getslice__

`VectorOfStringVector___getslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;ans = .Call('R_swig_VectorOfStringVector___getslice__', self, i, j, PACKAGE='CoolProp');
  ans <- new("_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t", ref=ans) ;
  
  ans
  
}

attr(`VectorOfStringVector___getslice__`, 'returnType') = '_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t'
attr(`VectorOfStringVector___getslice__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t', 'integer', 'integer')
class(`VectorOfStringVector___getslice__`) = c("SWIGFunction", class('VectorOfStringVector___getslice__'))

# Start of VectorOfStringVector___setslice__

`VectorOfStringVector___setslice__` = function(self, i, j, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_VectorOfStringVector___setslice__', self, i, j, v, PACKAGE='CoolProp');
  
}

attr(`VectorOfStringVector___setslice__`, 'returnType') = 'void'
attr(`VectorOfStringVector___setslice__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t', 'integer', 'integer', '_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t')
class(`VectorOfStringVector___setslice__`) = c("SWIGFunction", class('VectorOfStringVector___setslice__'))

# Start of VectorOfStringVector___delslice__

`VectorOfStringVector___delslice__` = function(self, i, j)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  ;.Call('R_swig_VectorOfStringVector___delslice__', self, i, j, PACKAGE='CoolProp');
  
}

attr(`VectorOfStringVector___delslice__`, 'returnType') = 'void'
attr(`VectorOfStringVector___delslice__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t', 'integer', 'integer')
class(`VectorOfStringVector___delslice__`) = c("SWIGFunction", class('VectorOfStringVector___delslice__'))

# Start of VectorOfStringVector___delitem__

`VectorOfStringVector___delitem__` = function(self, i)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_VectorOfStringVector___delitem__', self, i, PACKAGE='CoolProp');
  
}

attr(`VectorOfStringVector___delitem__`, 'returnType') = 'void'
attr(`VectorOfStringVector___delitem__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t', 'integer')
class(`VectorOfStringVector___delitem__`) = c("SWIGFunction", class('VectorOfStringVector___delitem__'))

# Start of VectorOfStringVector___getitem__

`VectorOfStringVector___getitem__` = function(self, i, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;ans = .Call('R_swig_VectorOfStringVector___getitem__', self, i, as.logical(.copy), PACKAGE='CoolProp');
  ans <- new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans) ;
  
  ans
  
}

attr(`VectorOfStringVector___getitem__`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`VectorOfStringVector___getitem__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t', 'integer')
class(`VectorOfStringVector___getitem__`) = c("SWIGFunction", class('VectorOfStringVector___getitem__'))

# Start of VectorOfStringVector___setitem__

`VectorOfStringVector___setitem__` = function(self, i, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VectorOfStringVector___setitem__', self, i, x, PACKAGE='CoolProp');
  
}

attr(`VectorOfStringVector___setitem__`, 'returnType') = 'void'
attr(`VectorOfStringVector___setitem__`, "inputTypes") = c('_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t', 'integer', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VectorOfStringVector___setitem__`) = c("SWIGFunction", class('VectorOfStringVector___setitem__'))

# Start of VectorOfStringVector_append

`VectorOfStringVector_append` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VectorOfStringVector_append', self, x, PACKAGE='CoolProp');
  
}

attr(`VectorOfStringVector_append`, 'returnType') = 'void'
attr(`VectorOfStringVector_append`, "inputTypes") = c('_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VectorOfStringVector_append`) = c("SWIGFunction", class('VectorOfStringVector_append'))

# Start of new_VectorOfStringVector

`VectorOfStringVector__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_VectorOfStringVector__SWIG_0', PACKAGE='CoolProp');
  ans <- new("_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_VectorOfStringVector)
  ans
  
}

attr(`VectorOfStringVector__SWIG_0`, 'returnType') = '_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t'
class(`VectorOfStringVector__SWIG_0`) = c("SWIGFunction", class('VectorOfStringVector__SWIG_0'))

# Start of new_VectorOfStringVector

`VectorOfStringVector__SWIG_1` = function(s_arg1)
{
  if (inherits(s_arg1, "ExternalReference")) s_arg1 = slot(s_arg1,"ref") 
  ;ans = .Call('R_swig_new_VectorOfStringVector__SWIG_1', s_arg1, PACKAGE='CoolProp');
  ans <- new("_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_VectorOfStringVector)
  ans
  
}

attr(`VectorOfStringVector__SWIG_1`, 'returnType') = '_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t'
attr(`VectorOfStringVector__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t')
class(`VectorOfStringVector__SWIG_1`) = c("SWIGFunction", class('VectorOfStringVector__SWIG_1'))

# Start of VectorOfStringVector_empty

`VectorOfStringVector_empty` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VectorOfStringVector_empty', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`VectorOfStringVector_empty`, 'returnType') = 'logical'
attr(`VectorOfStringVector_empty`, "inputTypes") = c('_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t')
class(`VectorOfStringVector_empty`) = c("SWIGFunction", class('VectorOfStringVector_empty'))

# Start of VectorOfStringVector_size

`VectorOfStringVector_size` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VectorOfStringVector_size', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`VectorOfStringVector_size`, 'returnType') = 'integer'
attr(`VectorOfStringVector_size`, "inputTypes") = c('_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t')
class(`VectorOfStringVector_size`) = c("SWIGFunction", class('VectorOfStringVector_size'))

# Start of VectorOfStringVector_clear

`VectorOfStringVector_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VectorOfStringVector_clear', self, PACKAGE='CoolProp');
  
}

attr(`VectorOfStringVector_clear`, 'returnType') = 'void'
attr(`VectorOfStringVector_clear`, "inputTypes") = c('_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t')
class(`VectorOfStringVector_clear`) = c("SWIGFunction", class('VectorOfStringVector_clear'))

# Start of VectorOfStringVector_swap

`VectorOfStringVector_swap` = function(self, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(v, "ExternalReference")) v = slot(v,"ref") 
  ;.Call('R_swig_VectorOfStringVector_swap', self, v, PACKAGE='CoolProp');
  
}

attr(`VectorOfStringVector_swap`, 'returnType') = 'void'
attr(`VectorOfStringVector_swap`, "inputTypes") = c('_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t', '_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t')
class(`VectorOfStringVector_swap`) = c("SWIGFunction", class('VectorOfStringVector_swap'))

# Start of VectorOfStringVector_get_allocator

`VectorOfStringVector_get_allocator` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_VectorOfStringVector_get_allocator', self, as.logical(.copy), PACKAGE='CoolProp');
  ans <- new("_p_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t", ref=ans);
  
  ans
  
}

attr(`VectorOfStringVector_get_allocator`, 'returnType') = '_p_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t'
attr(`VectorOfStringVector_get_allocator`, "inputTypes") = c('_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t')
class(`VectorOfStringVector_get_allocator`) = c("SWIGFunction", class('VectorOfStringVector_get_allocator'))

# Start of new_VectorOfStringVector

`VectorOfStringVector__SWIG_2` = function(size)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  ;ans = .Call('R_swig_new_VectorOfStringVector__SWIG_2', size, PACKAGE='CoolProp');
  ans <- new("_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_VectorOfStringVector)
  ans
  
}

attr(`VectorOfStringVector__SWIG_2`, 'returnType') = '_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t'
attr(`VectorOfStringVector__SWIG_2`, "inputTypes") = c('integer')
class(`VectorOfStringVector__SWIG_2`) = c("SWIGFunction", class('VectorOfStringVector__SWIG_2'))

# Start of VectorOfStringVector_pop_back

`VectorOfStringVector_pop_back` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VectorOfStringVector_pop_back', self, PACKAGE='CoolProp');
  
}

attr(`VectorOfStringVector_pop_back`, 'returnType') = 'void'
attr(`VectorOfStringVector_pop_back`, "inputTypes") = c('_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t')
class(`VectorOfStringVector_pop_back`) = c("SWIGFunction", class('VectorOfStringVector_pop_back'))

# Start of VectorOfStringVector_resize

`VectorOfStringVector_resize__SWIG_0` = function(self, new_size)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  ;.Call('R_swig_VectorOfStringVector_resize__SWIG_0', self, new_size, PACKAGE='CoolProp');
  
}

attr(`VectorOfStringVector_resize__SWIG_0`, 'returnType') = 'void'
attr(`VectorOfStringVector_resize__SWIG_0`, "inputTypes") = c('_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t', 'integer')
class(`VectorOfStringVector_resize__SWIG_0`) = c("SWIGFunction", class('VectorOfStringVector_resize__SWIG_0'))

# Start of new_VectorOfStringVector

`VectorOfStringVector__SWIG_3` = function(size, value)
{
  size = as.integer(size);
  
  if(length(size) > 1) {
    warning("using only the first element of size");
  };
  
  if (inherits(value, "ExternalReference")) value = slot(value,"ref") 
  ;ans = .Call('R_swig_new_VectorOfStringVector__SWIG_3', size, value, PACKAGE='CoolProp');
  ans <- new("_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_VectorOfStringVector)
  ans
  
}

attr(`VectorOfStringVector__SWIG_3`, 'returnType') = '_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t'
attr(`VectorOfStringVector__SWIG_3`, "inputTypes") = c('integer', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VectorOfStringVector__SWIG_3`) = c("SWIGFunction", class('VectorOfStringVector__SWIG_3'))

`VectorOfStringVector` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 4
  if (argc == 0) {
    f <- VectorOfStringVector__SWIG_0; 
  } else if (argc == 1) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 )) {
      f <- VectorOfStringVector__SWIG_2; 
    }
    else if (extends(argtypes[1], '_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t') && length(argv[[1]]) == 1) {
      f <- VectorOfStringVector__SWIG_1; 
    }
  } else if (argc == 2) {
    if (( (is.integer(argv[[1]]) || is.numeric(argv[[1]])) && length(argv[[1]]) == 1 ) && extends(argtypes[2], '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t') && length(argv[[2]]) == 1) {
      f <- VectorOfStringVector__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for VectorOfStringVector with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VectorOfStringVector_push_back

`VectorOfStringVector_push_back` = function(self, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VectorOfStringVector_push_back', self, x, PACKAGE='CoolProp');
  
}

attr(`VectorOfStringVector_push_back`, 'returnType') = 'void'
attr(`VectorOfStringVector_push_back`, "inputTypes") = c('_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VectorOfStringVector_push_back`) = c("SWIGFunction", class('VectorOfStringVector_push_back'))

# Start of VectorOfStringVector_front

`VectorOfStringVector_front` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_VectorOfStringVector_front', self, as.logical(.copy), PACKAGE='CoolProp');
  ans <- new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans) ;
  
  ans
  
}

attr(`VectorOfStringVector_front`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`VectorOfStringVector_front`, "inputTypes") = c('_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t')
class(`VectorOfStringVector_front`) = c("SWIGFunction", class('VectorOfStringVector_front'))

# Start of VectorOfStringVector_back

`VectorOfStringVector_back` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_VectorOfStringVector_back', self, as.logical(.copy), PACKAGE='CoolProp');
  ans <- new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans) ;
  
  ans
  
}

attr(`VectorOfStringVector_back`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`VectorOfStringVector_back`, "inputTypes") = c('_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t')
class(`VectorOfStringVector_back`) = c("SWIGFunction", class('VectorOfStringVector_back'))

# Start of VectorOfStringVector_assign

`VectorOfStringVector_assign` = function(self, n, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VectorOfStringVector_assign', self, n, x, PACKAGE='CoolProp');
  
}

attr(`VectorOfStringVector_assign`, 'returnType') = 'void'
attr(`VectorOfStringVector_assign`, "inputTypes") = c('_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t', 'integer', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VectorOfStringVector_assign`) = c("SWIGFunction", class('VectorOfStringVector_assign'))

# Start of VectorOfStringVector_resize

`VectorOfStringVector_resize__SWIG_1` = function(self, new_size, x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  new_size = as.integer(new_size);
  
  if(length(new_size) > 1) {
    warning("using only the first element of new_size");
  };
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  ;.Call('R_swig_VectorOfStringVector_resize__SWIG_1', self, new_size, x, PACKAGE='CoolProp');
  
}

attr(`VectorOfStringVector_resize__SWIG_1`, 'returnType') = 'void'
attr(`VectorOfStringVector_resize__SWIG_1`, "inputTypes") = c('_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t', 'integer', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`VectorOfStringVector_resize__SWIG_1`) = c("SWIGFunction", class('VectorOfStringVector_resize__SWIG_1'))

`VectorOfStringVector_resize` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (extends(argtypes[1], '_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- VectorOfStringVector_resize__SWIG_0; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && extends(argtypes[3], '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t') && length(argv[[3]]) == 1) {
      f <- VectorOfStringVector_resize__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for VectorOfStringVector_resize with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of VectorOfStringVector_reserve

`VectorOfStringVector_reserve` = function(self, n)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  n = as.integer(n);
  
  if(length(n) > 1) {
    warning("using only the first element of n");
  };
  
  ;.Call('R_swig_VectorOfStringVector_reserve', self, n, PACKAGE='CoolProp');
  
}

attr(`VectorOfStringVector_reserve`, 'returnType') = 'void'
attr(`VectorOfStringVector_reserve`, "inputTypes") = c('_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t', 'integer')
class(`VectorOfStringVector_reserve`) = c("SWIGFunction", class('VectorOfStringVector_reserve'))

# Start of VectorOfStringVector_capacity

`VectorOfStringVector_capacity` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_VectorOfStringVector_capacity', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`VectorOfStringVector_capacity`, 'returnType') = 'integer'
attr(`VectorOfStringVector_capacity`, "inputTypes") = c('_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t')
class(`VectorOfStringVector_capacity`) = c("SWIGFunction", class('VectorOfStringVector_capacity'))

# Start of delete_VectorOfStringVector

`delete_VectorOfStringVector` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_VectorOfStringVector', self, PACKAGE='CoolProp');
  
}

attr(`delete_VectorOfStringVector`, 'returnType') = 'void'
attr(`delete_VectorOfStringVector`, "inputTypes") = c('_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t')
class(`delete_VectorOfStringVector`) = c("SWIGFunction", class('delete_VectorOfStringVector'))

# Start of accessor method for std::vector<(std::vector<(std::string)>)>
setMethod('$', '_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t', function(x, name)

{
  accessorFuns = list('__nonzero__' = VectorOfStringVector___nonzero__, '__len__' = VectorOfStringVector___len__, 'pop' = VectorOfStringVector_pop, '__getslice__' = VectorOfStringVector___getslice__, '__setslice__' = VectorOfStringVector___setslice__, '__delslice__' = VectorOfStringVector___delslice__, '__delitem__' = VectorOfStringVector___delitem__, '__getitem__' = VectorOfStringVector___getitem__, '__setitem__' = VectorOfStringVector___setitem__, 'append' = VectorOfStringVector_append, 'empty' = VectorOfStringVector_empty, 'size' = VectorOfStringVector_size, 'clear' = VectorOfStringVector_clear, 'swap' = VectorOfStringVector_swap, 'get_allocator' = VectorOfStringVector_get_allocator, 'pop_back' = VectorOfStringVector_pop_back, 'resize' = VectorOfStringVector_resize, 'push_back' = VectorOfStringVector_push_back, 'front' = VectorOfStringVector_front, 'back' = VectorOfStringVector_back, 'assign' = VectorOfStringVector_assign, 'reserve' = VectorOfStringVector_reserve, 'capacity' = VectorOfStringVector_capacity);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for std::vector<(std::vector<(std::string)>)>
setMethod('delete', '_p_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t', function(obj) {delete_std__vectorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_std__allocatorT_std__vectorT_std__string_std__allocatorT_std__string_t_t_t_t(obj)})
# Start of SimpleState_rhomolar_set

`SimpleState_rhomolar_set` = function(self, s_rhomolar)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_SimpleState_rhomolar_set', self, s_rhomolar, PACKAGE='CoolProp');
  
}

attr(`SimpleState_rhomolar_set`, 'returnType') = 'void'
attr(`SimpleState_rhomolar_set`, "inputTypes") = c('_p_CoolProp__SimpleState', 'numeric')
class(`SimpleState_rhomolar_set`) = c("SWIGFunction", class('SimpleState_rhomolar_set'))

# Start of SimpleState_rhomolar_get

`SimpleState_rhomolar_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_SimpleState_rhomolar_get', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`SimpleState_rhomolar_get`, 'returnType') = 'numeric'
attr(`SimpleState_rhomolar_get`, "inputTypes") = c('_p_CoolProp__SimpleState')
class(`SimpleState_rhomolar_get`) = c("SWIGFunction", class('SimpleState_rhomolar_get'))

# Start of SimpleState_T_set

`SimpleState_T_set` = function(self, s_T)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_SimpleState_T_set', self, s_T, PACKAGE='CoolProp');
  
}

attr(`SimpleState_T_set`, 'returnType') = 'void'
attr(`SimpleState_T_set`, "inputTypes") = c('_p_CoolProp__SimpleState', 'numeric')
class(`SimpleState_T_set`) = c("SWIGFunction", class('SimpleState_T_set'))

# Start of SimpleState_T_get

`SimpleState_T_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_SimpleState_T_get', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`SimpleState_T_get`, 'returnType') = 'numeric'
attr(`SimpleState_T_get`, "inputTypes") = c('_p_CoolProp__SimpleState')
class(`SimpleState_T_get`) = c("SWIGFunction", class('SimpleState_T_get'))

# Start of SimpleState_p_set

`SimpleState_p_set` = function(self, s_p)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_SimpleState_p_set', self, s_p, PACKAGE='CoolProp');
  
}

attr(`SimpleState_p_set`, 'returnType') = 'void'
attr(`SimpleState_p_set`, "inputTypes") = c('_p_CoolProp__SimpleState', 'numeric')
class(`SimpleState_p_set`) = c("SWIGFunction", class('SimpleState_p_set'))

# Start of SimpleState_p_get

`SimpleState_p_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_SimpleState_p_get', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`SimpleState_p_get`, 'returnType') = 'numeric'
attr(`SimpleState_p_get`, "inputTypes") = c('_p_CoolProp__SimpleState')
class(`SimpleState_p_get`) = c("SWIGFunction", class('SimpleState_p_get'))

# Start of SimpleState_hmolar_set

`SimpleState_hmolar_set` = function(self, s_hmolar)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_SimpleState_hmolar_set', self, s_hmolar, PACKAGE='CoolProp');
  
}

attr(`SimpleState_hmolar_set`, 'returnType') = 'void'
attr(`SimpleState_hmolar_set`, "inputTypes") = c('_p_CoolProp__SimpleState', 'numeric')
class(`SimpleState_hmolar_set`) = c("SWIGFunction", class('SimpleState_hmolar_set'))

# Start of SimpleState_hmolar_get

`SimpleState_hmolar_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_SimpleState_hmolar_get', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`SimpleState_hmolar_get`, 'returnType') = 'numeric'
attr(`SimpleState_hmolar_get`, "inputTypes") = c('_p_CoolProp__SimpleState')
class(`SimpleState_hmolar_get`) = c("SWIGFunction", class('SimpleState_hmolar_get'))

# Start of SimpleState_smolar_set

`SimpleState_smolar_set` = function(self, s_smolar)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_SimpleState_smolar_set', self, s_smolar, PACKAGE='CoolProp');
  
}

attr(`SimpleState_smolar_set`, 'returnType') = 'void'
attr(`SimpleState_smolar_set`, "inputTypes") = c('_p_CoolProp__SimpleState', 'numeric')
class(`SimpleState_smolar_set`) = c("SWIGFunction", class('SimpleState_smolar_set'))

# Start of SimpleState_smolar_get

`SimpleState_smolar_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_SimpleState_smolar_get', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`SimpleState_smolar_get`, 'returnType') = 'numeric'
attr(`SimpleState_smolar_get`, "inputTypes") = c('_p_CoolProp__SimpleState')
class(`SimpleState_smolar_get`) = c("SWIGFunction", class('SimpleState_smolar_get'))

# Start of SimpleState_umolar_set

`SimpleState_umolar_set` = function(self, s_umolar)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_SimpleState_umolar_set', self, s_umolar, PACKAGE='CoolProp');
  
}

attr(`SimpleState_umolar_set`, 'returnType') = 'void'
attr(`SimpleState_umolar_set`, "inputTypes") = c('_p_CoolProp__SimpleState', 'numeric')
class(`SimpleState_umolar_set`) = c("SWIGFunction", class('SimpleState_umolar_set'))

# Start of SimpleState_umolar_get

`SimpleState_umolar_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_SimpleState_umolar_get', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`SimpleState_umolar_get`, 'returnType') = 'numeric'
attr(`SimpleState_umolar_get`, "inputTypes") = c('_p_CoolProp__SimpleState')
class(`SimpleState_umolar_get`) = c("SWIGFunction", class('SimpleState_umolar_get'))

# Start of SimpleState_Q_set

`SimpleState_Q_set` = function(self, s_Q)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_SimpleState_Q_set', self, s_Q, PACKAGE='CoolProp');
  
}

attr(`SimpleState_Q_set`, 'returnType') = 'void'
attr(`SimpleState_Q_set`, "inputTypes") = c('_p_CoolProp__SimpleState', 'numeric')
class(`SimpleState_Q_set`) = c("SWIGFunction", class('SimpleState_Q_set'))

# Start of SimpleState_Q_get

`SimpleState_Q_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_SimpleState_Q_get', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`SimpleState_Q_get`, 'returnType') = 'numeric'
attr(`SimpleState_Q_get`, "inputTypes") = c('_p_CoolProp__SimpleState')
class(`SimpleState_Q_get`) = c("SWIGFunction", class('SimpleState_Q_get'))

# Start of new_SimpleState

`SimpleState` = function()
{
  ;ans = .Call('R_swig_new_SimpleState', PACKAGE='CoolProp');
  ans <- new("_p_CoolProp__SimpleState", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_SimpleState)
  ans
  
}

attr(`SimpleState`, 'returnType') = '_p_CoolProp__SimpleState'
class(`SimpleState`) = c("SWIGFunction", class('SimpleState'))

# Start of SimpleState_fill

`SimpleState_fill` = function(self, v)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_SimpleState_fill', self, v, PACKAGE='CoolProp');
  
}

attr(`SimpleState_fill`, 'returnType') = 'void'
attr(`SimpleState_fill`, "inputTypes") = c('_p_CoolProp__SimpleState', 'numeric')
class(`SimpleState_fill`) = c("SWIGFunction", class('SimpleState_fill'))

# Start of SimpleState_is_valid

`SimpleState_is_valid` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_SimpleState_is_valid', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`SimpleState_is_valid`, 'returnType') = 'logical'
attr(`SimpleState_is_valid`, "inputTypes") = c('_p_CoolProp__SimpleState')
class(`SimpleState_is_valid`) = c("SWIGFunction", class('SimpleState_is_valid'))

# Start of delete_SimpleState

`delete_SimpleState` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_SimpleState', self, PACKAGE='CoolProp');
  
}

attr(`delete_SimpleState`, 'returnType') = 'void'
attr(`delete_SimpleState`, "inputTypes") = c('_p_CoolProp__SimpleState')
class(`delete_SimpleState`) = c("SWIGFunction", class('delete_SimpleState'))

# Start of accessor method for CoolProp::SimpleState
setMethod('$', '_p_CoolProp__SimpleState', function(x, name)

{
  accessorFuns = list('rhomolar' = SimpleState_rhomolar_get, 'T' = SimpleState_T_get, 'p' = SimpleState_p_get, 'hmolar' = SimpleState_hmolar_get, 'smolar' = SimpleState_smolar_get, 'umolar' = SimpleState_umolar_get, 'Q' = SimpleState_Q_get, 'fill' = SimpleState_fill, 'is_valid' = SimpleState_is_valid);
  vaccessors = c('rhomolar', 'T', 'p', 'hmolar', 'smolar', 'umolar', 'Q');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for CoolProp::SimpleState
# Start of accessor method for CoolProp::SimpleState
setMethod('$<-', '_p_CoolProp__SimpleState', function(x, name, value)

{
  accessorFuns = list('rhomolar' = SimpleState_rhomolar_set, 'T' = SimpleState_T_set, 'p' = SimpleState_p_set, 'hmolar' = SimpleState_hmolar_set, 'smolar' = SimpleState_smolar_set, 'umolar' = SimpleState_umolar_set, 'Q' = SimpleState_Q_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_CoolProp__SimpleState', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('rhomolar' = SimpleState_rhomolar_set, 'T' = SimpleState_T_set, 'p' = SimpleState_p_set, 'hmolar' = SimpleState_hmolar_set, 'smolar' = SimpleState_smolar_set, 'umolar' = SimpleState_umolar_set, 'Q' = SimpleState_Q_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for CoolProp::SimpleState
setMethod('delete', '_p_CoolProp__SimpleState', function(obj) {delete_CoolProp__SimpleState(obj)})
# Start definition of copy functions & methods for CoolProp::SimpleState
CopyToR_CoolProp__SimpleState = function(value, obj = new("CoolProp::SimpleState"))
{
  obj@rhomolar = value$rhomolar;
  obj@T = value$T;
  obj@p = value$p;
  obj@hmolar = value$hmolar;
  obj@smolar = value$smolar;
  obj@umolar = value$umolar;
  obj@Q = value$Q;
  obj;
}



CopyToC_CoolProp__SimpleState = function(value, obj)
{
  obj$rhomolar = value@rhomolar;
  obj$T = value@T;
  obj$p = value@p;
  obj$hmolar = value@hmolar;
  obj$smolar = value@smolar;
  obj$umolar = value@umolar;
  obj$Q = value@Q;
  obj
}



# Start definition of copy methods for CoolProp::SimpleState
setMethod('copyToR', '_p_CoolProp::SimpleState', CopyToR_CoolProp__SimpleState);
setMethod('copyToC', 'CoolProp::SimpleState', CopyToC_CoolProp__SimpleState);

# End definition of copy methods for CoolProp::SimpleState
# End definition of copy functions & methods for CoolProp::SimpleState
# Start of CriticalState_stable_set

`CriticalState_stable_set` = function(self, s_stable)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_stable = as.logical(s_stable);
  ;.Call('R_swig_CriticalState_stable_set', self, s_stable, PACKAGE='CoolProp');
  
}

attr(`CriticalState_stable_set`, 'returnType') = 'void'
attr(`CriticalState_stable_set`, "inputTypes") = c('_p_CoolProp__CriticalState', 'logical')
class(`CriticalState_stable_set`) = c("SWIGFunction", class('CriticalState_stable_set'))

# Start of CriticalState_stable_get

`CriticalState_stable_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_CriticalState_stable_get', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`CriticalState_stable_get`, 'returnType') = 'logical'
attr(`CriticalState_stable_get`, "inputTypes") = c('_p_CoolProp__CriticalState')
class(`CriticalState_stable_get`) = c("SWIGFunction", class('CriticalState_stable_get'))

# Start of new_CriticalState

`CriticalState` = function()
{
  ;ans = .Call('R_swig_new_CriticalState', PACKAGE='CoolProp');
  ans <- new("_p_CoolProp__CriticalState", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_CriticalState)
  ans
  
}

attr(`CriticalState`, 'returnType') = '_p_CoolProp__CriticalState'
class(`CriticalState`) = c("SWIGFunction", class('CriticalState'))

# Start of delete_CriticalState

`delete_CriticalState` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_CriticalState', self, PACKAGE='CoolProp');
  
}

attr(`delete_CriticalState`, 'returnType') = 'void'
attr(`delete_CriticalState`, "inputTypes") = c('_p_CoolProp__CriticalState')
class(`delete_CriticalState`) = c("SWIGFunction", class('delete_CriticalState'))

# Start of accessor method for CoolProp::CriticalState
setMethod('$', '_p_CoolProp__CriticalState', function(x, name)

{
  accessorFuns = list('stable' = CriticalState_stable_get);
  vaccessors = c('stable');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for CoolProp::CriticalState
# Start of accessor method for CoolProp::CriticalState
setMethod('$<-', '_p_CoolProp__CriticalState', function(x, name, value)

{
  accessorFuns = list('stable' = CriticalState_stable_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_CoolProp__CriticalState', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('stable' = CriticalState_stable_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for CoolProp::CriticalState
setMethod('delete', '_p_CoolProp__CriticalState', function(obj) {delete_CoolProp__CriticalState(obj)})
# Start definition of copy functions & methods for CoolProp::CriticalState
CopyToR_CoolProp__CriticalState = function(value, obj = new("CoolProp::CriticalState"))
{
  obj@stable = value$stable;
  obj;
}



CopyToC_CoolProp__CriticalState = function(value, obj)
{
  obj$stable = value@stable;
  obj
}



# Start definition of copy methods for CoolProp::CriticalState
setMethod('copyToR', '_p_CoolProp::CriticalState', CopyToR_CoolProp__CriticalState);
setMethod('copyToC', 'CoolProp::CriticalState', CopyToC_CoolProp__CriticalState);

# End definition of copy methods for CoolProp::CriticalState
# End definition of copy functions & methods for CoolProp::CriticalState
defineEnumeration('_CoolProp__SsatSimpleState__SsatSimpleStateEnum',
                    .values = c(
                        'SSAT_MAX_NOT_SET' = 0, 
                        'SSAT_MAX_DOESNT_EXIST' = 1, 
                        'SSAT_MAX_DOES_EXIST' = 2
))
# Start of SsatSimpleState_exists_set

`SsatSimpleState_exists_set` = function(self, s_exists)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_exists = enumToInteger(s_exists, "_CoolProp__SsatSimpleState__SsatSimpleStateEnum"); 
  
  if(length(s_exists) > 1) {
    warning("using only the first element of s_exists");
  };
  
  ;.Call('R_swig_SsatSimpleState_exists_set', self, s_exists, PACKAGE='CoolProp');
  
}

attr(`SsatSimpleState_exists_set`, 'returnType') = 'void'
attr(`SsatSimpleState_exists_set`, "inputTypes") = c('_p_CoolProp__SsatSimpleState', 'character')
class(`SsatSimpleState_exists_set`) = c("SWIGFunction", class('SsatSimpleState_exists_set'))

# Start of SsatSimpleState_exists_get

`SsatSimpleState_exists_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_SsatSimpleState_exists_get', self, as.logical(.copy), PACKAGE='CoolProp');
  ans = enumFromInteger(ans, "_CoolProp__SsatSimpleState__SsatSimpleStateEnum");
  
  ans
  
}

attr(`SsatSimpleState_exists_get`, 'returnType') = 'character'
attr(`SsatSimpleState_exists_get`, "inputTypes") = c('_p_CoolProp__SsatSimpleState')
class(`SsatSimpleState_exists_get`) = c("SWIGFunction", class('SsatSimpleState_exists_get'))

# Start of new_SsatSimpleState

`SsatSimpleState` = function()
{
  ;ans = .Call('R_swig_new_SsatSimpleState', PACKAGE='CoolProp');
  ans <- new("_p_CoolProp__SsatSimpleState", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_SsatSimpleState)
  ans
  
}

attr(`SsatSimpleState`, 'returnType') = '_p_CoolProp__SsatSimpleState'
class(`SsatSimpleState`) = c("SWIGFunction", class('SsatSimpleState'))

# Start of delete_SsatSimpleState

`delete_SsatSimpleState` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_SsatSimpleState', self, PACKAGE='CoolProp');
  
}

attr(`delete_SsatSimpleState`, 'returnType') = 'void'
attr(`delete_SsatSimpleState`, "inputTypes") = c('_p_CoolProp__SsatSimpleState')
class(`delete_SsatSimpleState`) = c("SWIGFunction", class('delete_SsatSimpleState'))

# Start of accessor method for CoolProp::SsatSimpleState
setMethod('$', '_p_CoolProp__SsatSimpleState', function(x, name)

{
  accessorFuns = list('exists' = SsatSimpleState_exists_get);
  vaccessors = c('exists');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for CoolProp::SsatSimpleState
# Start of accessor method for CoolProp::SsatSimpleState
setMethod('$<-', '_p_CoolProp__SsatSimpleState', function(x, name, value)

{
  accessorFuns = list('exists' = SsatSimpleState_exists_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_CoolProp__SsatSimpleState', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('exists' = SsatSimpleState_exists_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for CoolProp::SsatSimpleState
setMethod('delete', '_p_CoolProp__SsatSimpleState', function(obj) {delete_CoolProp__SsatSimpleState(obj)})
# Start definition of copy functions & methods for CoolProp::SsatSimpleState
CopyToR_CoolProp__SsatSimpleState = function(value, obj = new("CoolProp::SsatSimpleState"))
{
  obj@exists = value$exists;
  obj;
}



CopyToC_CoolProp__SsatSimpleState = function(value, obj)
{
  obj$exists = value@exists;
  obj
}



# Start definition of copy methods for CoolProp::SsatSimpleState
setMethod('copyToR', '_p_CoolProp::SsatSimpleState', CopyToR_CoolProp__SsatSimpleState);
setMethod('copyToC', 'CoolProp::SsatSimpleState', CopyToC_CoolProp__SsatSimpleState);

# End definition of copy methods for CoolProp::SsatSimpleState
# End definition of copy functions & methods for CoolProp::SsatSimpleState
defineEnumeration('_CoolProp__parameters',
                    .values = c(
                        'INVALID_PARAMETER' = 0, 
                        'igas_constant' = 1, 
                        'imolar_mass' = 2, 
                        'iacentric_factor' = 3, 
                        'irhomolar_reducing' = 4, 
                        'irhomolar_critical' = 5, 
                        'iT_reducing' = 6, 
                        'iT_critical' = 7, 
                        'irhomass_reducing' = 8, 
                        'irhomass_critical' = 9, 
                        'iP_critical' = 10, 
                        'iP_reducing' = 11, 
                        'iT_triple' = 12, 
                        'iP_triple' = 13, 
                        'iT_min' = 14, 
                        'iT_max' = 15, 
                        'iP_max' = 16, 
                        'iP_min' = 17, 
                        'idipole_moment' = 18, 
                        'iT' = 19, 
                        'iP' = 20, 
                        'iQ' = 21, 
                        'iTau' = 22, 
                        'iDelta' = 23, 
                        'iDmolar' = 24, 
                        'iHmolar' = 25, 
                        'iSmolar' = 26, 
                        'iCpmolar' = 27, 
                        'iCp0molar' = 28, 
                        'iCvmolar' = 29, 
                        'iUmolar' = 30, 
                        'iGmolar' = 31, 
                        'iHelmholtzmolar' = 32, 
                        'iSmolar_residual' = 33, 
                        'iDmass' = 34, 
                        'iHmass' = 35, 
                        'iSmass' = 36, 
                        'iCpmass' = 37, 
                        'iCp0mass' = 38, 
                        'iCvmass' = 39, 
                        'iUmass' = 40, 
                        'iGmass' = 41, 
                        'iHelmholtzmass' = 42, 
                        'iviscosity' = 43, 
                        'iconductivity' = 44, 
                        'isurface_tension' = 45, 
                        'iPrandtl' = 46, 
                        'ispeed_sound' = 47, 
                        'iisothermal_compressibility' = 48, 
                        'iisobaric_expansion_coefficient' = 49, 
                        'ifundamental_derivative_of_gas_dynamics' = 50, 
                        'ialphar' = 51, 
                        'idalphar_dtau_constdelta' = 52, 
                        'idalphar_ddelta_consttau' = 53, 
                        'ialpha0' = 54, 
                        'idalpha0_dtau_constdelta' = 55, 
                        'idalpha0_ddelta_consttau' = 56, 
                        'iBvirial' = 57, 
                        'iCvirial' = 58, 
                        'idBvirial_dT' = 59, 
                        'idCvirial_dT' = 60, 
                        'iZ' = 61, 
                        'iPIP' = 62, 
                        'ifraction_min' = 63, 
                        'ifraction_max' = 64, 
                        'iT_freeze' = 65, 
                        'iGWP20' = 66, 
                        'iGWP100' = 67, 
                        'iGWP500' = 68, 
                        'iFH' = 69, 
                        'iHH' = 70, 
                        'iPH' = 71, 
                        'iODP' = 72, 
                        'iPhase' = 73, 
                        'iundefined_parameter' = 74
))
defineEnumeration('_CoolProp__phases',
                    .values = c(
                        'iphase_liquid' = 0, 
                        'iphase_supercritical' = 1, 
                        'iphase_supercritical_gas' = 2, 
                        'iphase_supercritical_liquid' = 3, 
                        'iphase_critical_point' = 4, 
                        'iphase_gas' = 5, 
                        'iphase_twophase' = 6, 
                        'iphase_unknown' = 7, 
                        'iphase_not_imposed' = 8
))
# Start of get_parameter_information

`get_parameter_information` = function(key, info, .copy = FALSE)
{
  key = as.integer(key);
  
  if(length(key) > 1) {
    warning("using only the first element of key");
  };
  
  info = as(info, "character"); 
  ;.Call('R_swig_get_parameter_information', key, info, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`get_parameter_information`, 'returnType') = 'character'
attr(`get_parameter_information`, "inputTypes") = c('integer', 'character')
class(`get_parameter_information`) = c("SWIGFunction", class('get_parameter_information'))

# Start of get_parameter_index

`get_parameter_index` = function(param_name, .copy = FALSE)
{
  param_name = as(param_name, "character"); 
  ;ans = .Call('R_swig_get_parameter_index', param_name, as.logical(.copy), PACKAGE='CoolProp');
  ans = enumFromInteger(ans, "_CoolProp__parameters");
  
  ans
  
}

attr(`get_parameter_index`, 'returnType') = 'character'
attr(`get_parameter_index`, "inputTypes") = c('character')
class(`get_parameter_index`) = c("SWIGFunction", class('get_parameter_index'))

# Start of get_phase_index

`get_phase_index` = function(param_name, .copy = FALSE)
{
  param_name = as(param_name, "character"); 
  ;ans = .Call('R_swig_get_phase_index', param_name, as.logical(.copy), PACKAGE='CoolProp');
  ans = enumFromInteger(ans, "_CoolProp__phases");
  
  ans
  
}

attr(`get_phase_index`, 'returnType') = 'character'
attr(`get_phase_index`, "inputTypes") = c('character')
class(`get_phase_index`) = c("SWIGFunction", class('get_phase_index'))

# Start of is_trivial_parameter

`is_trivial_parameter` = function(key, .copy = FALSE)
{
  key = as.integer(key);
  
  if(length(key) > 1) {
    warning("using only the first element of key");
  };
  
  ;.Call('R_swig_is_trivial_parameter', key, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`is_trivial_parameter`, 'returnType') = 'logical'
attr(`is_trivial_parameter`, "inputTypes") = c('integer')
class(`is_trivial_parameter`) = c("SWIGFunction", class('is_trivial_parameter'))

# Start of is_valid_parameter

`is_valid_parameter` = function(name, iOutput, .copy = FALSE)
{
  name = as(name, "character"); 
  iOutput = enumToInteger(iOutput, "_p_CoolProp__parameters"); 
  ;.Call('R_swig_is_valid_parameter', name, iOutput, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`is_valid_parameter`, 'returnType') = 'logical'
attr(`is_valid_parameter`, "inputTypes") = c('character', 'character')
class(`is_valid_parameter`) = c("SWIGFunction", class('is_valid_parameter'))

# Start of is_valid_first_derivative

`is_valid_first_derivative` = function(name, iOf, iWrt, iConstant, .copy = FALSE)
{
  name = as(name, "character"); 
  iOf = enumToInteger(iOf, "_p_CoolProp__parameters"); 
  iWrt = enumToInteger(iWrt, "_p_CoolProp__parameters"); 
  iConstant = enumToInteger(iConstant, "_p_CoolProp__parameters"); 
  ;.Call('R_swig_is_valid_first_derivative', name, iOf, iWrt, iConstant, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`is_valid_first_derivative`, 'returnType') = 'logical'
attr(`is_valid_first_derivative`, "inputTypes") = c('character', 'character', 'character', 'character')
class(`is_valid_first_derivative`) = c("SWIGFunction", class('is_valid_first_derivative'))

# Start of is_valid_first_saturation_derivative

`is_valid_first_saturation_derivative` = function(name, iOf, iWrt, .copy = FALSE)
{
  name = as(name, "character"); 
  iOf = enumToInteger(iOf, "_p_CoolProp__parameters"); 
  iWrt = enumToInteger(iWrt, "_p_CoolProp__parameters"); 
  ;.Call('R_swig_is_valid_first_saturation_derivative', name, iOf, iWrt, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`is_valid_first_saturation_derivative`, 'returnType') = 'logical'
attr(`is_valid_first_saturation_derivative`, "inputTypes") = c('character', 'character', 'character')
class(`is_valid_first_saturation_derivative`) = c("SWIGFunction", class('is_valid_first_saturation_derivative'))

# Start of is_valid_second_derivative

`is_valid_second_derivative` = function(name, iOf1, iWrt1, iConstant1, iWrt2, iConstant2, .copy = FALSE)
{
  name = as(name, "character"); 
  iOf1 = enumToInteger(iOf1, "_p_CoolProp__parameters"); 
  iWrt1 = enumToInteger(iWrt1, "_p_CoolProp__parameters"); 
  iConstant1 = enumToInteger(iConstant1, "_p_CoolProp__parameters"); 
  iWrt2 = enumToInteger(iWrt2, "_p_CoolProp__parameters"); 
  iConstant2 = enumToInteger(iConstant2, "_p_CoolProp__parameters"); 
  ;.Call('R_swig_is_valid_second_derivative', name, iOf1, iWrt1, iConstant1, iWrt2, iConstant2, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`is_valid_second_derivative`, 'returnType') = 'logical'
attr(`is_valid_second_derivative`, "inputTypes") = c('character', 'character', 'character', 'character', 'character', 'character')
class(`is_valid_second_derivative`) = c("SWIGFunction", class('is_valid_second_derivative'))

# Start of get_csv_parameter_list

`get_csv_parameter_list` = function(.copy = FALSE)
{
  ;.Call('R_swig_get_csv_parameter_list', as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`get_csv_parameter_list`, 'returnType') = 'character'
class(`get_csv_parameter_list`) = c("SWIGFunction", class('get_csv_parameter_list'))

defineEnumeration('_CoolProp__composition_types',
                    .values = c(
                        'IFRAC_MASS' = 0, 
                        'IFRAC_MOLE' = 1, 
                        'IFRAC_VOLUME' = 2, 
                        'IFRAC_UNDEFINED' = 3, 
                        'IFRAC_PURE' = 4
))
defineEnumeration('_CoolProp__fluid_types',
                    .values = c(
                        'FLUID_TYPE_PURE' = 0, 
                        'FLUID_TYPE_PSEUDOPURE' = 1, 
                        'FLUID_TYPE_REFPROP' = 2, 
                        'FLUID_TYPE_INCOMPRESSIBLE_LIQUID' = 3, 
                        'FLUID_TYPE_INCOMPRESSIBLE_SOLUTION' = 4, 
                        'FLUID_TYPE_UNDEFINED' = 5
))
defineEnumeration('_CoolProp__input_pairs',
                    .values = c(
                        'INPUT_PAIR_INVALID' = 0, 
                        'QT_INPUTS' = 1, 
                        'PQ_INPUTS' = 2, 
                        'QSmolar_INPUTS' = 3, 
                        'QSmass_INPUTS' = 4, 
                        'HmolarQ_INPUTS' = 5, 
                        'HmassQ_INPUTS' = 6, 
                        'DmolarQ_INPUTS' = 7, 
                        'DmassQ_INPUTS' = 8, 
                        'PT_INPUTS' = 9, 
                        'DmassT_INPUTS' = 10, 
                        'DmolarT_INPUTS' = 11, 
                        'HmolarT_INPUTS' = 12, 
                        'HmassT_INPUTS' = 13, 
                        'SmolarT_INPUTS' = 14, 
                        'SmassT_INPUTS' = 15, 
                        'TUmolar_INPUTS' = 16, 
                        'TUmass_INPUTS' = 17, 
                        'DmassP_INPUTS' = 18, 
                        'DmolarP_INPUTS' = 19, 
                        'HmassP_INPUTS' = 20, 
                        'HmolarP_INPUTS' = 21, 
                        'PSmass_INPUTS' = 22, 
                        'PSmolar_INPUTS' = 23, 
                        'PUmass_INPUTS' = 24, 
                        'PUmolar_INPUTS' = 25, 
                        'HmassSmass_INPUTS' = 26, 
                        'HmolarSmolar_INPUTS' = 27, 
                        'SmassUmass_INPUTS' = 28, 
                        'SmolarUmolar_INPUTS' = 29, 
                        'DmassHmass_INPUTS' = 30, 
                        'DmolarHmolar_INPUTS' = 31, 
                        'DmassSmass_INPUTS' = 32, 
                        'DmolarSmolar_INPUTS' = 33, 
                        'DmassUmass_INPUTS' = 34, 
                        'DmolarUmolar_INPUTS' = 35
))
# Start of match_pair

`match_pair` = function(key1, key2, x1, x2, swap, .copy = FALSE)
{
  key1 = enumToInteger(key1, "_CoolProp__parameters"); 
  
  if(length(key1) > 1) {
    warning("using only the first element of key1");
  };
  
  key2 = enumToInteger(key2, "_CoolProp__parameters"); 
  
  if(length(key2) > 1) {
    warning("using only the first element of key2");
  };
  
  x1 = enumToInteger(x1, "_CoolProp__parameters"); 
  
  if(length(x1) > 1) {
    warning("using only the first element of x1");
  };
  
  x2 = enumToInteger(x2, "_CoolProp__parameters"); 
  
  if(length(x2) > 1) {
    warning("using only the first element of x2");
  };
  
  swap = as.logical(swap);
  ;.Call('R_swig_match_pair', key1, key2, x1, x2, swap, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`match_pair`, 'returnType') = 'logical'
attr(`match_pair`, "inputTypes") = c('character', 'character', 'character', 'character', '_p_bool')
class(`match_pair`) = c("SWIGFunction", class('match_pair'))

# Start of get_input_pair_index

`get_input_pair_index` = function(input_pair_name, .copy = FALSE)
{
  input_pair_name = as(input_pair_name, "character"); 
  ;ans = .Call('R_swig_get_input_pair_index', input_pair_name, as.logical(.copy), PACKAGE='CoolProp');
  ans = enumFromInteger(ans, "_CoolProp__input_pairs");
  
  ans
  
}

attr(`get_input_pair_index`, 'returnType') = 'character'
attr(`get_input_pair_index`, "inputTypes") = c('character')
class(`get_input_pair_index`) = c("SWIGFunction", class('get_input_pair_index'))

# Start of get_input_pair_short_desc

`get_input_pair_short_desc` = function(pair, .copy = FALSE)
{
  pair = enumToInteger(pair, "_CoolProp__input_pairs"); 
  
  if(length(pair) > 1) {
    warning("using only the first element of pair");
  };
  
  ;.Call('R_swig_get_input_pair_short_desc', pair, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`get_input_pair_short_desc`, 'returnType') = 'character'
attr(`get_input_pair_short_desc`, "inputTypes") = c('character')
class(`get_input_pair_short_desc`) = c("SWIGFunction", class('get_input_pair_short_desc'))

# Start of get_input_pair_long_desc

`get_input_pair_long_desc` = function(pair, .copy = FALSE)
{
  pair = enumToInteger(pair, "_CoolProp__input_pairs"); 
  
  if(length(pair) > 1) {
    warning("using only the first element of pair");
  };
  
  ;.Call('R_swig_get_input_pair_long_desc', pair, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`get_input_pair_long_desc`, 'returnType') = 'character'
attr(`get_input_pair_long_desc`, "inputTypes") = c('character')
class(`get_input_pair_long_desc`) = c("SWIGFunction", class('get_input_pair_long_desc'))

# Start of split_input_pair

`split_input_pair` = function(pair, p1, p2)
{
  pair = enumToInteger(pair, "_CoolProp__input_pairs"); 
  
  if(length(pair) > 1) {
    warning("using only the first element of pair");
  };
  
  p1 = enumToInteger(p1, "_p_CoolProp__parameters"); 
  p2 = enumToInteger(p2, "_p_CoolProp__parameters"); 
  ;.Call('R_swig_split_input_pair', pair, p1, p2, PACKAGE='CoolProp');
  
}

attr(`split_input_pair`, 'returnType') = 'void'
attr(`split_input_pair`, "inputTypes") = c('character', 'character', 'character')
class(`split_input_pair`) = c("SWIGFunction", class('split_input_pair'))

# Start of get_mixture_binary_pair_data

`get_mixture_binary_pair_data` = function(CAS1, CAS2, param, .copy = FALSE)
{
  CAS1 = as(CAS1, "character"); 
  CAS2 = as(CAS2, "character"); 
  param = as(param, "character"); 
  ;.Call('R_swig_get_mixture_binary_pair_data', CAS1, CAS2, param, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`get_mixture_binary_pair_data`, 'returnType') = 'character'
attr(`get_mixture_binary_pair_data`, "inputTypes") = c('character', 'character', 'character')
class(`get_mixture_binary_pair_data`) = c("SWIGFunction", class('get_mixture_binary_pair_data'))

# Start of set_mixture_binary_pair_data

`set_mixture_binary_pair_data` = function(CAS1, CAS2, param, val)
{
  CAS1 = as(CAS1, "character"); 
  CAS2 = as(CAS2, "character"); 
  param = as(param, "character"); 
  
  ;.Call('R_swig_set_mixture_binary_pair_data', CAS1, CAS2, param, val, PACKAGE='CoolProp');
  
}

attr(`set_mixture_binary_pair_data`, 'returnType') = 'void'
attr(`set_mixture_binary_pair_data`, "inputTypes") = c('character', 'character', 'character', 'numeric')
class(`set_mixture_binary_pair_data`) = c("SWIGFunction", class('set_mixture_binary_pair_data'))

defineEnumeration('_CoolProp__backend_families',
                    .values = c(
                        'INVALID_BACKEND_FAMILY' = 0, 
                        'HEOS_BACKEND_FAMILY' = 1, 
                        'REFPROP_BACKEND_FAMILY' = 2, 
                        'INCOMP_BACKEND_FAMILY' = 3, 
                        'IF97_BACKEND_FAMILY' = 4, 
                        'TREND_BACKEND_FAMILY' = 5, 
                        'TTSE_BACKEND_FAMILY' = 6, 
                        'BICUBIC_BACKEND_FAMILY' = 7, 
                        'SRK_BACKEND_FAMILY' = 8, 
                        'PR_BACKEND_FAMILY' = 9, 
                        'VTPR_BACKEND_FAMILY' = 10
))
defineEnumeration('_CoolProp__backends',
                    .values = c(
                        'INVALID_BACKEND' = 0, 
                        'HEOS_BACKEND_PURE' = 1, 
                        'HEOS_BACKEND_MIX' = 2, 
                        'REFPROP_BACKEND_PURE' = 3, 
                        'REFPROP_BACKEND_MIX' = 4, 
                        'INCOMP_BACKEND' = 5, 
                        'IF97_BACKEND' = 6, 
                        'TREND_BACKEND' = 7, 
                        'TTSE_BACKEND' = 8, 
                        'BICUBIC_BACKEND' = 9, 
                        'SRK_BACKEND' = 10, 
                        'PR_BACKEND' = 11, 
                        'VTPR_BACKEND' = 12
))
# Start of extract_backend_families

`extract_backend_families` = function(backend_string, f1, f2)
{
  backend_string = as(backend_string, "character"); 
  f1 = enumToInteger(f1, "_p_CoolProp__backend_families"); 
  f2 = enumToInteger(f2, "_p_CoolProp__backend_families"); 
  ;.Call('R_swig_extract_backend_families', backend_string, f1, f2, PACKAGE='CoolProp');
  
}

attr(`extract_backend_families`, 'returnType') = 'void'
attr(`extract_backend_families`, "inputTypes") = c('character', 'character', 'character')
class(`extract_backend_families`) = c("SWIGFunction", class('extract_backend_families'))

# Start of extract_backend_families_string

`extract_backend_families_string` = function(backend_string, f1, f2)
{
  backend_string = as(backend_string, "character"); 
  f1 = enumToInteger(f1, "_p_CoolProp__backend_families"); 
  f2 = as(f2, "character"); 
  ;.Call('R_swig_extract_backend_families_string', backend_string, f1, f2, PACKAGE='CoolProp');
  
}

attr(`extract_backend_families_string`, 'returnType') = 'void'
attr(`extract_backend_families_string`, "inputTypes") = c('character', 'character', 'character')
class(`extract_backend_families_string`) = c("SWIGFunction", class('extract_backend_families_string'))

# Start of get_backend_string

`get_backend_string` = function(backend, .copy = FALSE)
{
  backend = enumToInteger(backend, "_CoolProp__backends"); 
  
  if(length(backend) > 1) {
    warning("using only the first element of backend");
  };
  
  ;.Call('R_swig_get_backend_string', backend, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`get_backend_string`, 'returnType') = 'character'
attr(`get_backend_string`, "inputTypes") = c('character')
class(`get_backend_string`) = c("SWIGFunction", class('get_backend_string'))

# Start of SpinodalData_tau_set

`SpinodalData_tau_set` = function(self, s_tau)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_tau, "ExternalReference")) s_tau = slot(s_tau,"ref") 
  ;.Call('R_swig_SpinodalData_tau_set', self, s_tau, PACKAGE='CoolProp');
  
}

attr(`SpinodalData_tau_set`, 'returnType') = 'void'
attr(`SpinodalData_tau_set`, "inputTypes") = c('_p_CoolProp__SpinodalData', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`SpinodalData_tau_set`) = c("SWIGFunction", class('SpinodalData_tau_set'))

# Start of SpinodalData_tau_get

`SpinodalData_tau_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_SpinodalData_tau_get', self, PACKAGE='CoolProp');
  
}

attr(`SpinodalData_tau_get`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`SpinodalData_tau_get`, "inputTypes") = c('_p_CoolProp__SpinodalData')
class(`SpinodalData_tau_get`) = c("SWIGFunction", class('SpinodalData_tau_get'))

# Start of SpinodalData_delta_set

`SpinodalData_delta_set` = function(self, s_delta)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_delta, "ExternalReference")) s_delta = slot(s_delta,"ref") 
  ;.Call('R_swig_SpinodalData_delta_set', self, s_delta, PACKAGE='CoolProp');
  
}

attr(`SpinodalData_delta_set`, 'returnType') = 'void'
attr(`SpinodalData_delta_set`, "inputTypes") = c('_p_CoolProp__SpinodalData', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`SpinodalData_delta_set`) = c("SWIGFunction", class('SpinodalData_delta_set'))

# Start of SpinodalData_delta_get

`SpinodalData_delta_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_SpinodalData_delta_get', self, PACKAGE='CoolProp');
  
}

attr(`SpinodalData_delta_get`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`SpinodalData_delta_get`, "inputTypes") = c('_p_CoolProp__SpinodalData')
class(`SpinodalData_delta_get`) = c("SWIGFunction", class('SpinodalData_delta_get'))

# Start of SpinodalData_M1_set

`SpinodalData_M1_set` = function(self, s_M1)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_M1, "ExternalReference")) s_M1 = slot(s_M1,"ref") 
  ;.Call('R_swig_SpinodalData_M1_set', self, s_M1, PACKAGE='CoolProp');
  
}

attr(`SpinodalData_M1_set`, 'returnType') = 'void'
attr(`SpinodalData_M1_set`, "inputTypes") = c('_p_CoolProp__SpinodalData', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`SpinodalData_M1_set`) = c("SWIGFunction", class('SpinodalData_M1_set'))

# Start of SpinodalData_M1_get

`SpinodalData_M1_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_SpinodalData_M1_get', self, PACKAGE='CoolProp');
  
}

attr(`SpinodalData_M1_get`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`SpinodalData_M1_get`, "inputTypes") = c('_p_CoolProp__SpinodalData')
class(`SpinodalData_M1_get`) = c("SWIGFunction", class('SpinodalData_M1_get'))

# Start of new_SpinodalData

`SpinodalData` = function()
{
  ;ans = .Call('R_swig_new_SpinodalData', PACKAGE='CoolProp');
  ans <- new("_p_CoolProp__SpinodalData", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_SpinodalData)
  ans
  
}

attr(`SpinodalData`, 'returnType') = '_p_CoolProp__SpinodalData'
class(`SpinodalData`) = c("SWIGFunction", class('SpinodalData'))

# Start of delete_SpinodalData

`delete_SpinodalData` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_SpinodalData', self, PACKAGE='CoolProp');
  
}

attr(`delete_SpinodalData`, 'returnType') = 'void'
attr(`delete_SpinodalData`, "inputTypes") = c('_p_CoolProp__SpinodalData')
class(`delete_SpinodalData`) = c("SWIGFunction", class('delete_SpinodalData'))

# Start of accessor method for CoolProp::SpinodalData
setMethod('$', '_p_CoolProp__SpinodalData', function(x, name)

{
  accessorFuns = list('tau' = SpinodalData_tau_get, 'delta' = SpinodalData_delta_get, 'M1' = SpinodalData_M1_get);
  vaccessors = c('tau', 'delta', 'M1');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for CoolProp::SpinodalData
# Start of accessor method for CoolProp::SpinodalData
setMethod('$<-', '_p_CoolProp__SpinodalData', function(x, name, value)

{
  accessorFuns = list('tau' = SpinodalData_tau_set, 'delta' = SpinodalData_delta_set, 'M1' = SpinodalData_M1_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_CoolProp__SpinodalData', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('tau' = SpinodalData_tau_set, 'delta' = SpinodalData_delta_set, 'M1' = SpinodalData_M1_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for CoolProp::SpinodalData
setMethod('delete', '_p_CoolProp__SpinodalData', function(obj) {delete_CoolProp__SpinodalData(obj)})
# Start of GuessesStructure_T_set

`GuessesStructure_T_set` = function(self, s_T)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_GuessesStructure_T_set', self, s_T, PACKAGE='CoolProp');
  
}

attr(`GuessesStructure_T_set`, 'returnType') = 'void'
attr(`GuessesStructure_T_set`, "inputTypes") = c('_p_CoolProp__GuessesStructure', 'numeric')
class(`GuessesStructure_T_set`) = c("SWIGFunction", class('GuessesStructure_T_set'))

# Start of GuessesStructure_T_get

`GuessesStructure_T_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GuessesStructure_T_get', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`GuessesStructure_T_get`, 'returnType') = 'numeric'
attr(`GuessesStructure_T_get`, "inputTypes") = c('_p_CoolProp__GuessesStructure')
class(`GuessesStructure_T_get`) = c("SWIGFunction", class('GuessesStructure_T_get'))

# Start of GuessesStructure_p_set

`GuessesStructure_p_set` = function(self, s_p)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_GuessesStructure_p_set', self, s_p, PACKAGE='CoolProp');
  
}

attr(`GuessesStructure_p_set`, 'returnType') = 'void'
attr(`GuessesStructure_p_set`, "inputTypes") = c('_p_CoolProp__GuessesStructure', 'numeric')
class(`GuessesStructure_p_set`) = c("SWIGFunction", class('GuessesStructure_p_set'))

# Start of GuessesStructure_p_get

`GuessesStructure_p_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GuessesStructure_p_get', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`GuessesStructure_p_get`, 'returnType') = 'numeric'
attr(`GuessesStructure_p_get`, "inputTypes") = c('_p_CoolProp__GuessesStructure')
class(`GuessesStructure_p_get`) = c("SWIGFunction", class('GuessesStructure_p_get'))

# Start of GuessesStructure_rhomolar_set

`GuessesStructure_rhomolar_set` = function(self, s_rhomolar)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_GuessesStructure_rhomolar_set', self, s_rhomolar, PACKAGE='CoolProp');
  
}

attr(`GuessesStructure_rhomolar_set`, 'returnType') = 'void'
attr(`GuessesStructure_rhomolar_set`, "inputTypes") = c('_p_CoolProp__GuessesStructure', 'numeric')
class(`GuessesStructure_rhomolar_set`) = c("SWIGFunction", class('GuessesStructure_rhomolar_set'))

# Start of GuessesStructure_rhomolar_get

`GuessesStructure_rhomolar_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GuessesStructure_rhomolar_get', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`GuessesStructure_rhomolar_get`, 'returnType') = 'numeric'
attr(`GuessesStructure_rhomolar_get`, "inputTypes") = c('_p_CoolProp__GuessesStructure')
class(`GuessesStructure_rhomolar_get`) = c("SWIGFunction", class('GuessesStructure_rhomolar_get'))

# Start of GuessesStructure_hmolar_set

`GuessesStructure_hmolar_set` = function(self, s_hmolar)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_GuessesStructure_hmolar_set', self, s_hmolar, PACKAGE='CoolProp');
  
}

attr(`GuessesStructure_hmolar_set`, 'returnType') = 'void'
attr(`GuessesStructure_hmolar_set`, "inputTypes") = c('_p_CoolProp__GuessesStructure', 'numeric')
class(`GuessesStructure_hmolar_set`) = c("SWIGFunction", class('GuessesStructure_hmolar_set'))

# Start of GuessesStructure_hmolar_get

`GuessesStructure_hmolar_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GuessesStructure_hmolar_get', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`GuessesStructure_hmolar_get`, 'returnType') = 'numeric'
attr(`GuessesStructure_hmolar_get`, "inputTypes") = c('_p_CoolProp__GuessesStructure')
class(`GuessesStructure_hmolar_get`) = c("SWIGFunction", class('GuessesStructure_hmolar_get'))

# Start of GuessesStructure_smolar_set

`GuessesStructure_smolar_set` = function(self, s_smolar)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_GuessesStructure_smolar_set', self, s_smolar, PACKAGE='CoolProp');
  
}

attr(`GuessesStructure_smolar_set`, 'returnType') = 'void'
attr(`GuessesStructure_smolar_set`, "inputTypes") = c('_p_CoolProp__GuessesStructure', 'numeric')
class(`GuessesStructure_smolar_set`) = c("SWIGFunction", class('GuessesStructure_smolar_set'))

# Start of GuessesStructure_smolar_get

`GuessesStructure_smolar_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GuessesStructure_smolar_get', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`GuessesStructure_smolar_get`, 'returnType') = 'numeric'
attr(`GuessesStructure_smolar_get`, "inputTypes") = c('_p_CoolProp__GuessesStructure')
class(`GuessesStructure_smolar_get`) = c("SWIGFunction", class('GuessesStructure_smolar_get'))

# Start of GuessesStructure_rhomolar_liq_set

`GuessesStructure_rhomolar_liq_set` = function(self, s_rhomolar_liq)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_GuessesStructure_rhomolar_liq_set', self, s_rhomolar_liq, PACKAGE='CoolProp');
  
}

attr(`GuessesStructure_rhomolar_liq_set`, 'returnType') = 'void'
attr(`GuessesStructure_rhomolar_liq_set`, "inputTypes") = c('_p_CoolProp__GuessesStructure', 'numeric')
class(`GuessesStructure_rhomolar_liq_set`) = c("SWIGFunction", class('GuessesStructure_rhomolar_liq_set'))

# Start of GuessesStructure_rhomolar_liq_get

`GuessesStructure_rhomolar_liq_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GuessesStructure_rhomolar_liq_get', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`GuessesStructure_rhomolar_liq_get`, 'returnType') = 'numeric'
attr(`GuessesStructure_rhomolar_liq_get`, "inputTypes") = c('_p_CoolProp__GuessesStructure')
class(`GuessesStructure_rhomolar_liq_get`) = c("SWIGFunction", class('GuessesStructure_rhomolar_liq_get'))

# Start of GuessesStructure_rhomolar_vap_set

`GuessesStructure_rhomolar_vap_set` = function(self, s_rhomolar_vap)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_GuessesStructure_rhomolar_vap_set', self, s_rhomolar_vap, PACKAGE='CoolProp');
  
}

attr(`GuessesStructure_rhomolar_vap_set`, 'returnType') = 'void'
attr(`GuessesStructure_rhomolar_vap_set`, "inputTypes") = c('_p_CoolProp__GuessesStructure', 'numeric')
class(`GuessesStructure_rhomolar_vap_set`) = c("SWIGFunction", class('GuessesStructure_rhomolar_vap_set'))

# Start of GuessesStructure_rhomolar_vap_get

`GuessesStructure_rhomolar_vap_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GuessesStructure_rhomolar_vap_get', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`GuessesStructure_rhomolar_vap_get`, 'returnType') = 'numeric'
attr(`GuessesStructure_rhomolar_vap_get`, "inputTypes") = c('_p_CoolProp__GuessesStructure')
class(`GuessesStructure_rhomolar_vap_get`) = c("SWIGFunction", class('GuessesStructure_rhomolar_vap_get'))

# Start of GuessesStructure_x_set

`GuessesStructure_x_set` = function(self, s_x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_x, "ExternalReference")) s_x = slot(s_x,"ref") 
  ;.Call('R_swig_GuessesStructure_x_set', self, s_x, PACKAGE='CoolProp');
  
}

attr(`GuessesStructure_x_set`, 'returnType') = 'void'
attr(`GuessesStructure_x_set`, "inputTypes") = c('_p_CoolProp__GuessesStructure', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`GuessesStructure_x_set`) = c("SWIGFunction", class('GuessesStructure_x_set'))

# Start of GuessesStructure_x_get

`GuessesStructure_x_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GuessesStructure_x_get', self, PACKAGE='CoolProp');
  
}

attr(`GuessesStructure_x_get`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`GuessesStructure_x_get`, "inputTypes") = c('_p_CoolProp__GuessesStructure')
class(`GuessesStructure_x_get`) = c("SWIGFunction", class('GuessesStructure_x_get'))

# Start of GuessesStructure_y_set

`GuessesStructure_y_set` = function(self, s_y)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_y, "ExternalReference")) s_y = slot(s_y,"ref") 
  ;.Call('R_swig_GuessesStructure_y_set', self, s_y, PACKAGE='CoolProp');
  
}

attr(`GuessesStructure_y_set`, 'returnType') = 'void'
attr(`GuessesStructure_y_set`, "inputTypes") = c('_p_CoolProp__GuessesStructure', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`GuessesStructure_y_set`) = c("SWIGFunction", class('GuessesStructure_y_set'))

# Start of GuessesStructure_y_get

`GuessesStructure_y_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_GuessesStructure_y_get', self, PACKAGE='CoolProp');
  
}

attr(`GuessesStructure_y_get`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`GuessesStructure_y_get`, "inputTypes") = c('_p_CoolProp__GuessesStructure')
class(`GuessesStructure_y_get`) = c("SWIGFunction", class('GuessesStructure_y_get'))

# Start of new_GuessesStructure

`GuessesStructure` = function()
{
  ;ans = .Call('R_swig_new_GuessesStructure', PACKAGE='CoolProp');
  ans <- new("_p_CoolProp__GuessesStructure", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_GuessesStructure)
  ans
  
}

attr(`GuessesStructure`, 'returnType') = '_p_CoolProp__GuessesStructure'
class(`GuessesStructure`) = c("SWIGFunction", class('GuessesStructure'))

# Start of delete_GuessesStructure

`delete_GuessesStructure` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_GuessesStructure', self, PACKAGE='CoolProp');
  
}

attr(`delete_GuessesStructure`, 'returnType') = 'void'
attr(`delete_GuessesStructure`, "inputTypes") = c('_p_CoolProp__GuessesStructure')
class(`delete_GuessesStructure`) = c("SWIGFunction", class('delete_GuessesStructure'))

# Start of accessor method for CoolProp::GuessesStructure
setMethod('$', '_p_CoolProp__GuessesStructure', function(x, name)

{
  accessorFuns = list('T' = GuessesStructure_T_get, 'p' = GuessesStructure_p_get, 'rhomolar' = GuessesStructure_rhomolar_get, 'hmolar' = GuessesStructure_hmolar_get, 'smolar' = GuessesStructure_smolar_get, 'rhomolar_liq' = GuessesStructure_rhomolar_liq_get, 'rhomolar_vap' = GuessesStructure_rhomolar_vap_get, 'x' = GuessesStructure_x_get, 'y' = GuessesStructure_y_get);
  vaccessors = c('T', 'p', 'rhomolar', 'hmolar', 'smolar', 'rhomolar_liq', 'rhomolar_vap', 'x', 'y');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for CoolProp::GuessesStructure
# Start of accessor method for CoolProp::GuessesStructure
setMethod('$<-', '_p_CoolProp__GuessesStructure', function(x, name, value)

{
  accessorFuns = list('T' = GuessesStructure_T_set, 'p' = GuessesStructure_p_set, 'rhomolar' = GuessesStructure_rhomolar_set, 'hmolar' = GuessesStructure_hmolar_set, 'smolar' = GuessesStructure_smolar_set, 'rhomolar_liq' = GuessesStructure_rhomolar_liq_set, 'rhomolar_vap' = GuessesStructure_rhomolar_vap_set, 'x' = GuessesStructure_x_set, 'y' = GuessesStructure_y_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_CoolProp__GuessesStructure', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('T' = GuessesStructure_T_set, 'p' = GuessesStructure_p_set, 'rhomolar' = GuessesStructure_rhomolar_set, 'hmolar' = GuessesStructure_hmolar_set, 'smolar' = GuessesStructure_smolar_set, 'rhomolar_liq' = GuessesStructure_rhomolar_liq_set, 'rhomolar_vap' = GuessesStructure_rhomolar_vap_set, 'x' = GuessesStructure_x_set, 'y' = GuessesStructure_y_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for CoolProp::GuessesStructure
setMethod('delete', '_p_CoolProp__GuessesStructure', function(obj) {delete_CoolProp__GuessesStructure(obj)})
# Start of delete_AbstractState

`delete_AbstractState` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_AbstractState', self, PACKAGE='CoolProp');
  
}

attr(`delete_AbstractState`, 'returnType') = 'void'
attr(`delete_AbstractState`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`delete_AbstractState`) = c("SWIGFunction", class('delete_AbstractState'))

# Start of AbstractState_factory

`AbstractState_factory__SWIG_0` = function(backend, fluid_names)
{
  backend = as(backend, "character"); 
  fluid_names = as(fluid_names, "character"); 
  ;ans = .Call('R_swig_AbstractState_factory__SWIG_0', backend, fluid_names, PACKAGE='CoolProp');
  ans <- new("_p_CoolProp__AbstractState", ref=ans) ;
  
  ans
  
}

attr(`AbstractState_factory__SWIG_0`, 'returnType') = '_p_CoolProp__AbstractState'
attr(`AbstractState_factory__SWIG_0`, "inputTypes") = c('character', 'character')
class(`AbstractState_factory__SWIG_0`) = c("SWIGFunction", class('AbstractState_factory__SWIG_0'))

# Start of AbstractState_factory

`AbstractState_factory__SWIG_1` = function(backend, fluid_names)
{
  backend = as(backend, "character"); 
  if (inherits(fluid_names, "ExternalReference")) fluid_names = slot(fluid_names,"ref") 
  ;ans = .Call('R_swig_AbstractState_factory__SWIG_1', backend, fluid_names, PACKAGE='CoolProp');
  ans <- new("_p_CoolProp__AbstractState", ref=ans) ;
  
  ans
  
}

attr(`AbstractState_factory__SWIG_1`, 'returnType') = '_p_CoolProp__AbstractState'
attr(`AbstractState_factory__SWIG_1`, "inputTypes") = c('character', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t')
class(`AbstractState_factory__SWIG_1`) = c("SWIGFunction", class('AbstractState_factory__SWIG_1'))

`AbstractState_factory` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 2) {
    if (is.character(argv[[1]]) && length(argv[[1]]) == 1 && is.character(argv[[2]]) && length(argv[[2]]) == 1) {
      f <- AbstractState_factory__SWIG_0; 
    }
    else if (is.character(argv[[1]]) && length(argv[[1]]) == 1 && extends(argtypes[2], '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t') && length(argv[[2]]) == 1) {
      f <- AbstractState_factory__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for AbstractState_factory with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of AbstractState_set_T

`AbstractState_set_T` = function(self, T)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_AbstractState_set_T', self, T, PACKAGE='CoolProp');
  
}

attr(`AbstractState_set_T`, 'returnType') = 'void'
attr(`AbstractState_set_T`, "inputTypes") = c('_p_CoolProp__AbstractState', 'numeric')
class(`AbstractState_set_T`) = c("SWIGFunction", class('AbstractState_set_T'))

# Start of AbstractState_backend_name

`AbstractState_backend_name` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_backend_name', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_backend_name`, 'returnType') = 'character'
attr(`AbstractState_backend_name`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_backend_name`) = c("SWIGFunction", class('AbstractState_backend_name'))

# Start of AbstractState_using_mole_fractions

`AbstractState_using_mole_fractions` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_using_mole_fractions', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_using_mole_fractions`, 'returnType') = 'logical'
attr(`AbstractState_using_mole_fractions`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_using_mole_fractions`) = c("SWIGFunction", class('AbstractState_using_mole_fractions'))

# Start of AbstractState_using_mass_fractions

`AbstractState_using_mass_fractions` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_using_mass_fractions', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_using_mass_fractions`, 'returnType') = 'logical'
attr(`AbstractState_using_mass_fractions`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_using_mass_fractions`) = c("SWIGFunction", class('AbstractState_using_mass_fractions'))

# Start of AbstractState_using_volu_fractions

`AbstractState_using_volu_fractions` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_using_volu_fractions', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_using_volu_fractions`, 'returnType') = 'logical'
attr(`AbstractState_using_volu_fractions`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_using_volu_fractions`) = c("SWIGFunction", class('AbstractState_using_volu_fractions'))

# Start of AbstractState_set_mole_fractions

`AbstractState_set_mole_fractions` = function(self, mole_fractions)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_AbstractState_set_mole_fractions', self, mole_fractions, PACKAGE='CoolProp');
  
}

attr(`AbstractState_set_mole_fractions`, 'returnType') = 'void'
attr(`AbstractState_set_mole_fractions`, "inputTypes") = c('_p_CoolProp__AbstractState', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`AbstractState_set_mole_fractions`) = c("SWIGFunction", class('AbstractState_set_mole_fractions'))

# Start of AbstractState_set_mass_fractions

`AbstractState_set_mass_fractions` = function(self, mass_fractions)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_AbstractState_set_mass_fractions', self, mass_fractions, PACKAGE='CoolProp');
  
}

attr(`AbstractState_set_mass_fractions`, 'returnType') = 'void'
attr(`AbstractState_set_mass_fractions`, "inputTypes") = c('_p_CoolProp__AbstractState', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`AbstractState_set_mass_fractions`) = c("SWIGFunction", class('AbstractState_set_mass_fractions'))

# Start of AbstractState_set_volu_fractions

`AbstractState_set_volu_fractions` = function(self, volu_fractions)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_AbstractState_set_volu_fractions', self, volu_fractions, PACKAGE='CoolProp');
  
}

attr(`AbstractState_set_volu_fractions`, 'returnType') = 'void'
attr(`AbstractState_set_volu_fractions`, "inputTypes") = c('_p_CoolProp__AbstractState', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`AbstractState_set_volu_fractions`) = c("SWIGFunction", class('AbstractState_set_volu_fractions'))

# Start of AbstractState_mole_fractions_liquid

`AbstractState_mole_fractions_liquid` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_mole_fractions_liquid', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_mole_fractions_liquid`, 'returnType') = 'numeric'
attr(`AbstractState_mole_fractions_liquid`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_mole_fractions_liquid`) = c("SWIGFunction", class('AbstractState_mole_fractions_liquid'))

# Start of AbstractState_mole_fractions_vapor

`AbstractState_mole_fractions_vapor` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_mole_fractions_vapor', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_mole_fractions_vapor`, 'returnType') = 'numeric'
attr(`AbstractState_mole_fractions_vapor`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_mole_fractions_vapor`) = c("SWIGFunction", class('AbstractState_mole_fractions_vapor'))

# Start of AbstractState_get_mole_fractions

`AbstractState_get_mole_fractions` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_AbstractState_get_mole_fractions', self, as.logical(.copy), PACKAGE='CoolProp');
  ans <- new("_p_std__vectorT_CoolPropDbl_std__allocatorT_CoolPropDbl_t_t", ref=ans) ;
  
  ans
  
}

attr(`AbstractState_get_mole_fractions`, 'returnType') = '_p_std__vectorT_CoolPropDbl_std__allocatorT_CoolPropDbl_t_t'
attr(`AbstractState_get_mole_fractions`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_get_mole_fractions`) = c("SWIGFunction", class('AbstractState_get_mole_fractions'))

# Start of AbstractState_get_mass_fractions

`AbstractState_get_mass_fractions` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_AbstractState_get_mass_fractions', self, as.logical(.copy), PACKAGE='CoolProp');
  ans <- new("_p_std__vectorT_CoolPropDbl_std__allocatorT_CoolPropDbl_t_t", ref=ans);
  
  ans
  
}

attr(`AbstractState_get_mass_fractions`, 'returnType') = '_p_std__vectorT_CoolPropDbl_std__allocatorT_CoolPropDbl_t_t'
attr(`AbstractState_get_mass_fractions`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_get_mass_fractions`) = c("SWIGFunction", class('AbstractState_get_mass_fractions'))

# Start of AbstractState_update

`AbstractState_update` = function(self, input_pair, Value1, Value2)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  input_pair = enumToInteger(input_pair, "_CoolProp__input_pairs"); 
  
  if(length(input_pair) > 1) {
    warning("using only the first element of input_pair");
  };
  
  
  
  ;.Call('R_swig_AbstractState_update', self, input_pair, Value1, Value2, PACKAGE='CoolProp');
  
}

attr(`AbstractState_update`, 'returnType') = 'void'
attr(`AbstractState_update`, "inputTypes") = c('_p_CoolProp__AbstractState', 'character', 'numeric', 'numeric')
class(`AbstractState_update`) = c("SWIGFunction", class('AbstractState_update'))

# Start of AbstractState_update_with_guesses

`AbstractState_update_with_guesses` = function(self, input_pair, Value1, Value2, guesses)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  input_pair = enumToInteger(input_pair, "_CoolProp__input_pairs"); 
  
  if(length(input_pair) > 1) {
    warning("using only the first element of input_pair");
  };
  
  
  
  if (inherits(guesses, "ExternalReference")) guesses = slot(guesses,"ref") 
  ;.Call('R_swig_AbstractState_update_with_guesses', self, input_pair, Value1, Value2, guesses, PACKAGE='CoolProp');
  
}

attr(`AbstractState_update_with_guesses`, 'returnType') = 'void'
attr(`AbstractState_update_with_guesses`, "inputTypes") = c('_p_CoolProp__AbstractState', 'character', 'numeric', 'numeric', '_p_CoolProp__GuessesStructure')
class(`AbstractState_update_with_guesses`) = c("SWIGFunction", class('AbstractState_update_with_guesses'))

# Start of AbstractState_available_in_high_level

`AbstractState_available_in_high_level` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_available_in_high_level', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_available_in_high_level`, 'returnType') = 'logical'
attr(`AbstractState_available_in_high_level`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_available_in_high_level`) = c("SWIGFunction", class('AbstractState_available_in_high_level'))

# Start of AbstractState_fluid_param_string

`AbstractState_fluid_param_string` = function(self, s_arg2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_arg2 = as(s_arg2, "character"); 
  ;.Call('R_swig_AbstractState_fluid_param_string', self, s_arg2, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_fluid_param_string`, 'returnType') = 'character'
attr(`AbstractState_fluid_param_string`, "inputTypes") = c('_p_CoolProp__AbstractState', 'character')
class(`AbstractState_fluid_param_string`) = c("SWIGFunction", class('AbstractState_fluid_param_string'))

# Start of AbstractState_fluid_names

`AbstractState_fluid_names` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_AbstractState_fluid_names', self, as.logical(.copy), PACKAGE='CoolProp');
  ans <- new("_p_std__vectorT_std__string_std__allocatorT_std__string_t_t", ref=ans);
  
  ans
  
}

attr(`AbstractState_fluid_names`, 'returnType') = '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t'
attr(`AbstractState_fluid_names`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_fluid_names`) = c("SWIGFunction", class('AbstractState_fluid_names'))

# Start of AbstractState_set_binary_interaction_double

`AbstractState_set_binary_interaction_double__SWIG_0` = function(self, CAS1, CAS2, parameter, value)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  CAS1 = as(CAS1, "character"); 
  CAS2 = as(CAS2, "character"); 
  parameter = as(parameter, "character"); 
  
  ;.Call('R_swig_AbstractState_set_binary_interaction_double__SWIG_0', self, CAS1, CAS2, parameter, value, PACKAGE='CoolProp');
  
}

attr(`AbstractState_set_binary_interaction_double__SWIG_0`, 'returnType') = 'void'
attr(`AbstractState_set_binary_interaction_double__SWIG_0`, "inputTypes") = c('_p_CoolProp__AbstractState', 'character', 'character', 'character', 'numeric')
class(`AbstractState_set_binary_interaction_double__SWIG_0`) = c("SWIGFunction", class('AbstractState_set_binary_interaction_double__SWIG_0'))

# Start of AbstractState_set_binary_interaction_double

`AbstractState_set_binary_interaction_double__SWIG_1` = function(self, i, j, parameter, value)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  parameter = as(parameter, "character"); 
  
  ;.Call('R_swig_AbstractState_set_binary_interaction_double__SWIG_1', self, i, j, parameter, value, PACKAGE='CoolProp');
  
}

attr(`AbstractState_set_binary_interaction_double__SWIG_1`, 'returnType') = 'void'
attr(`AbstractState_set_binary_interaction_double__SWIG_1`, "inputTypes") = c('_p_CoolProp__AbstractState', 'integer', 'integer', 'character', 'numeric')
class(`AbstractState_set_binary_interaction_double__SWIG_1`) = c("SWIGFunction", class('AbstractState_set_binary_interaction_double__SWIG_1'))

`AbstractState_set_binary_interaction_double` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 5) {
    if (extends(argtypes[1], '_p_CoolProp__AbstractState') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && is.character(argv[[4]]) && length(argv[[4]]) == 1 && ( is.numeric(argv[[5]]) && length(argv[[5]]) == 1 )) {
      f <- AbstractState_set_binary_interaction_double__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_CoolProp__AbstractState') && is.character(argv[[2]]) && length(argv[[2]]) == 1 && is.character(argv[[3]]) && length(argv[[3]]) == 1 && is.character(argv[[4]]) && length(argv[[4]]) == 1 && ( is.numeric(argv[[5]]) && length(argv[[5]]) == 1 )) {
      f <- AbstractState_set_binary_interaction_double__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for AbstractState_set_binary_interaction_double with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of AbstractState_set_binary_interaction_string

`AbstractState_set_binary_interaction_string` = function(self, CAS1, CAS2, parameter, value)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  CAS1 = as(CAS1, "character"); 
  CAS2 = as(CAS2, "character"); 
  parameter = as(parameter, "character"); 
  value = as(value, "character"); 
  ;.Call('R_swig_AbstractState_set_binary_interaction_string', self, CAS1, CAS2, parameter, value, PACKAGE='CoolProp');
  
}

attr(`AbstractState_set_binary_interaction_string`, 'returnType') = 'void'
attr(`AbstractState_set_binary_interaction_string`, "inputTypes") = c('_p_CoolProp__AbstractState', 'character', 'character', 'character', 'character')
class(`AbstractState_set_binary_interaction_string`) = c("SWIGFunction", class('AbstractState_set_binary_interaction_string'))

# Start of AbstractState_get_binary_interaction_double

`AbstractState_get_binary_interaction_double__SWIG_0` = function(self, CAS1, CAS2, parameter, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  CAS1 = as(CAS1, "character"); 
  CAS2 = as(CAS2, "character"); 
  parameter = as(parameter, "character"); 
  ;.Call('R_swig_AbstractState_get_binary_interaction_double__SWIG_0', self, CAS1, CAS2, parameter, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_get_binary_interaction_double__SWIG_0`, 'returnType') = 'numeric'
attr(`AbstractState_get_binary_interaction_double__SWIG_0`, "inputTypes") = c('_p_CoolProp__AbstractState', 'character', 'character', 'character')
class(`AbstractState_get_binary_interaction_double__SWIG_0`) = c("SWIGFunction", class('AbstractState_get_binary_interaction_double__SWIG_0'))

# Start of AbstractState_get_binary_interaction_double

`AbstractState_get_binary_interaction_double__SWIG_1` = function(self, i, j, parameter, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  parameter = as(parameter, "character"); 
  ;.Call('R_swig_AbstractState_get_binary_interaction_double__SWIG_1', self, i, j, parameter, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_get_binary_interaction_double__SWIG_1`, 'returnType') = 'numeric'
attr(`AbstractState_get_binary_interaction_double__SWIG_1`, "inputTypes") = c('_p_CoolProp__AbstractState', 'integer', 'integer', 'character')
class(`AbstractState_get_binary_interaction_double__SWIG_1`) = c("SWIGFunction", class('AbstractState_get_binary_interaction_double__SWIG_1'))

`AbstractState_get_binary_interaction_double` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 4) {
    if (extends(argtypes[1], '_p_CoolProp__AbstractState') && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 ) && ( (is.integer(argv[[3]]) || is.numeric(argv[[3]])) && length(argv[[3]]) == 1 ) && is.character(argv[[4]]) && length(argv[[4]]) == 1) {
      f <- AbstractState_get_binary_interaction_double__SWIG_1; 
    }
    else if (extends(argtypes[1], '_p_CoolProp__AbstractState') && is.character(argv[[2]]) && length(argv[[2]]) == 1 && is.character(argv[[3]]) && length(argv[[3]]) == 1 && is.character(argv[[4]]) && length(argv[[4]]) == 1) {
      f <- AbstractState_get_binary_interaction_double__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for AbstractState_get_binary_interaction_double with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of AbstractState_get_binary_interaction_string

`AbstractState_get_binary_interaction_string` = function(self, CAS1, CAS2, parameter, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  CAS1 = as(CAS1, "character"); 
  CAS2 = as(CAS2, "character"); 
  parameter = as(parameter, "character"); 
  ;.Call('R_swig_AbstractState_get_binary_interaction_string', self, CAS1, CAS2, parameter, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_get_binary_interaction_string`, 'returnType') = 'character'
attr(`AbstractState_get_binary_interaction_string`, "inputTypes") = c('_p_CoolProp__AbstractState', 'character', 'character', 'character')
class(`AbstractState_get_binary_interaction_string`) = c("SWIGFunction", class('AbstractState_get_binary_interaction_string'))

# Start of AbstractState_apply_simple_mixing_rule

`AbstractState_apply_simple_mixing_rule` = function(self, i, j, model)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  j = as.integer(j);
  
  if(length(j) > 1) {
    warning("using only the first element of j");
  };
  
  model = as(model, "character"); 
  ;.Call('R_swig_AbstractState_apply_simple_mixing_rule', self, i, j, model, PACKAGE='CoolProp');
  
}

attr(`AbstractState_apply_simple_mixing_rule`, 'returnType') = 'void'
attr(`AbstractState_apply_simple_mixing_rule`, "inputTypes") = c('_p_CoolProp__AbstractState', 'integer', 'integer', 'character')
class(`AbstractState_apply_simple_mixing_rule`) = c("SWIGFunction", class('AbstractState_apply_simple_mixing_rule'))

# Start of AbstractState_set_fluid_parameter_double

`AbstractState_set_fluid_parameter_double` = function(self, i, parameter, value)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  parameter = as(parameter, "character"); 
  
  ;.Call('R_swig_AbstractState_set_fluid_parameter_double', self, i, parameter, value, PACKAGE='CoolProp');
  
}

attr(`AbstractState_set_fluid_parameter_double`, 'returnType') = 'void'
attr(`AbstractState_set_fluid_parameter_double`, "inputTypes") = c('_p_CoolProp__AbstractState', 'integer', 'character', 'numeric')
class(`AbstractState_set_fluid_parameter_double`) = c("SWIGFunction", class('AbstractState_set_fluid_parameter_double'))

# Start of AbstractState_clear

`AbstractState_clear` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_clear', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_clear`, 'returnType') = 'logical'
attr(`AbstractState_clear`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_clear`) = c("SWIGFunction", class('AbstractState_clear'))

# Start of AbstractState_get_reducing_state

`AbstractState_get_reducing_state` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_AbstractState_get_reducing_state', self, as.logical(.copy), PACKAGE='CoolProp');
  ans <- new("_p_CoolProp__SimpleState", ref=ans) ;
  
  ans
  
}

attr(`AbstractState_get_reducing_state`, 'returnType') = '_p_CoolProp__SimpleState'
attr(`AbstractState_get_reducing_state`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_get_reducing_state`) = c("SWIGFunction", class('AbstractState_get_reducing_state'))

# Start of AbstractState_get_state

`AbstractState_get_state` = function(self, state, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  state = as(state, "character"); 
  ;ans = .Call('R_swig_AbstractState_get_state', self, state, as.logical(.copy), PACKAGE='CoolProp');
  ans <- new("_p_CoolProp__SimpleState", ref=ans) ;
  
  ans
  
}

attr(`AbstractState_get_state`, 'returnType') = '_p_CoolProp__SimpleState'
attr(`AbstractState_get_state`, "inputTypes") = c('_p_CoolProp__AbstractState', 'character')
class(`AbstractState_get_state`) = c("SWIGFunction", class('AbstractState_get_state'))

# Start of AbstractState_Tmin

`AbstractState_Tmin` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_Tmin', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_Tmin`, 'returnType') = 'numeric'
attr(`AbstractState_Tmin`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_Tmin`) = c("SWIGFunction", class('AbstractState_Tmin'))

# Start of AbstractState_Tmax

`AbstractState_Tmax` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_Tmax', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_Tmax`, 'returnType') = 'numeric'
attr(`AbstractState_Tmax`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_Tmax`) = c("SWIGFunction", class('AbstractState_Tmax'))

# Start of AbstractState_pmax

`AbstractState_pmax` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_pmax', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_pmax`, 'returnType') = 'numeric'
attr(`AbstractState_pmax`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_pmax`) = c("SWIGFunction", class('AbstractState_pmax'))

# Start of AbstractState_Ttriple

`AbstractState_Ttriple` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_Ttriple', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_Ttriple`, 'returnType') = 'numeric'
attr(`AbstractState_Ttriple`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_Ttriple`) = c("SWIGFunction", class('AbstractState_Ttriple'))

# Start of AbstractState_phase

`AbstractState_phase` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_AbstractState_phase', self, as.logical(.copy), PACKAGE='CoolProp');
  ans = enumFromInteger(ans, "_CoolProp__phases");
  
  ans
  
}

attr(`AbstractState_phase`, 'returnType') = 'character'
attr(`AbstractState_phase`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_phase`) = c("SWIGFunction", class('AbstractState_phase'))

# Start of AbstractState_specify_phase

`AbstractState_specify_phase` = function(self, phase)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  phase = enumToInteger(phase, "_CoolProp__phases"); 
  
  if(length(phase) > 1) {
    warning("using only the first element of phase");
  };
  
  ;.Call('R_swig_AbstractState_specify_phase', self, phase, PACKAGE='CoolProp');
  
}

attr(`AbstractState_specify_phase`, 'returnType') = 'void'
attr(`AbstractState_specify_phase`, "inputTypes") = c('_p_CoolProp__AbstractState', 'character')
class(`AbstractState_specify_phase`) = c("SWIGFunction", class('AbstractState_specify_phase'))

# Start of AbstractState_unspecify_phase

`AbstractState_unspecify_phase` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_unspecify_phase', self, PACKAGE='CoolProp');
  
}

attr(`AbstractState_unspecify_phase`, 'returnType') = 'void'
attr(`AbstractState_unspecify_phase`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_unspecify_phase`) = c("SWIGFunction", class('AbstractState_unspecify_phase'))

# Start of AbstractState_T_critical

`AbstractState_T_critical` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_T_critical', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_T_critical`, 'returnType') = 'numeric'
attr(`AbstractState_T_critical`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_T_critical`) = c("SWIGFunction", class('AbstractState_T_critical'))

# Start of AbstractState_p_critical

`AbstractState_p_critical` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_p_critical', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_p_critical`, 'returnType') = 'numeric'
attr(`AbstractState_p_critical`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_p_critical`) = c("SWIGFunction", class('AbstractState_p_critical'))

# Start of AbstractState_rhomolar_critical

`AbstractState_rhomolar_critical` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_rhomolar_critical', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_rhomolar_critical`, 'returnType') = 'numeric'
attr(`AbstractState_rhomolar_critical`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_rhomolar_critical`) = c("SWIGFunction", class('AbstractState_rhomolar_critical'))

# Start of AbstractState_rhomass_critical

`AbstractState_rhomass_critical` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_rhomass_critical', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_rhomass_critical`, 'returnType') = 'numeric'
attr(`AbstractState_rhomass_critical`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_rhomass_critical`) = c("SWIGFunction", class('AbstractState_rhomass_critical'))

# Start of AbstractState_all_critical_points

`AbstractState_all_critical_points` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_AbstractState_all_critical_points', self, as.logical(.copy), PACKAGE='CoolProp');
  ans <- new("_p_std__vectorT_CoolProp__CriticalState_std__allocatorT_CoolProp__CriticalState_t_t", ref=ans);
  
  ans
  
}

attr(`AbstractState_all_critical_points`, 'returnType') = '_p_std__vectorT_CoolProp__CriticalState_std__allocatorT_CoolProp__CriticalState_t_t'
attr(`AbstractState_all_critical_points`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_all_critical_points`) = c("SWIGFunction", class('AbstractState_all_critical_points'))

# Start of AbstractState_build_spinodal

`AbstractState_build_spinodal` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_build_spinodal', self, PACKAGE='CoolProp');
  
}

attr(`AbstractState_build_spinodal`, 'returnType') = 'void'
attr(`AbstractState_build_spinodal`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_build_spinodal`) = c("SWIGFunction", class('AbstractState_build_spinodal'))

# Start of AbstractState_get_spinodal_data

`AbstractState_get_spinodal_data` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_AbstractState_get_spinodal_data', self, as.logical(.copy), PACKAGE='CoolProp');
  ans <- new("_p_CoolProp__SpinodalData", ref=ans);
  
  ans
  
}

attr(`AbstractState_get_spinodal_data`, 'returnType') = '_p_CoolProp__SpinodalData'
attr(`AbstractState_get_spinodal_data`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_get_spinodal_data`) = c("SWIGFunction", class('AbstractState_get_spinodal_data'))

# Start of AbstractState_criticality_contour_values

`AbstractState_criticality_contour_values` = function(self, L1star, M1star)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  
  ;.Call('R_swig_AbstractState_criticality_contour_values', self, L1star, M1star, PACKAGE='CoolProp');
  
}

attr(`AbstractState_criticality_contour_values`, 'returnType') = 'void'
attr(`AbstractState_criticality_contour_values`, "inputTypes") = c('_p_CoolProp__AbstractState', 'numeric', 'numeric')
class(`AbstractState_criticality_contour_values`) = c("SWIGFunction", class('AbstractState_criticality_contour_values'))

# Start of AbstractState_tangent_plane_distance

`AbstractState_tangent_plane_distance__SWIG_0` = function(self, T, p, w, rhomolar_guess, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  
  
  
  ;.Call('R_swig_AbstractState_tangent_plane_distance__SWIG_0', self, T, p, w, rhomolar_guess, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_tangent_plane_distance__SWIG_0`, 'returnType') = 'numeric'
attr(`AbstractState_tangent_plane_distance__SWIG_0`, "inputTypes") = c('_p_CoolProp__AbstractState', 'numeric', 'numeric', '_p_std__vectorT_double_std__allocatorT_double_t_t', 'numeric')
class(`AbstractState_tangent_plane_distance__SWIG_0`) = c("SWIGFunction", class('AbstractState_tangent_plane_distance__SWIG_0'))

# Start of AbstractState_tangent_plane_distance

`AbstractState_tangent_plane_distance__SWIG_1` = function(self, T, p, w, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  
  
  ;.Call('R_swig_AbstractState_tangent_plane_distance__SWIG_1', self, T, p, w, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_tangent_plane_distance__SWIG_1`, 'returnType') = 'numeric'
attr(`AbstractState_tangent_plane_distance__SWIG_1`, "inputTypes") = c('_p_CoolProp__AbstractState', 'numeric', 'numeric', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`AbstractState_tangent_plane_distance__SWIG_1`) = c("SWIGFunction", class('AbstractState_tangent_plane_distance__SWIG_1'))

`AbstractState_tangent_plane_distance` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 4) {
    if (extends(argtypes[1], '_p_CoolProp__AbstractState') && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 ) && ( is.numeric(argv[[3]]) && length(argv[[3]]) == 1 ) && ( is.numeric(argv[[4]]) )) {
      f <- AbstractState_tangent_plane_distance__SWIG_1; 
    }
  } else if (argc == 5) {
    if (extends(argtypes[1], '_p_CoolProp__AbstractState') && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 ) && ( is.numeric(argv[[3]]) && length(argv[[3]]) == 1 ) && ( is.numeric(argv[[4]]) ) && ( is.numeric(argv[[5]]) && length(argv[[5]]) == 1 )) {
      f <- AbstractState_tangent_plane_distance__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for AbstractState_tangent_plane_distance with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of AbstractState_T_reducing

`AbstractState_T_reducing` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_T_reducing', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_T_reducing`, 'returnType') = 'numeric'
attr(`AbstractState_T_reducing`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_T_reducing`) = c("SWIGFunction", class('AbstractState_T_reducing'))

# Start of AbstractState_rhomolar_reducing

`AbstractState_rhomolar_reducing` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_rhomolar_reducing', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_rhomolar_reducing`, 'returnType') = 'numeric'
attr(`AbstractState_rhomolar_reducing`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_rhomolar_reducing`) = c("SWIGFunction", class('AbstractState_rhomolar_reducing'))

# Start of AbstractState_rhomass_reducing

`AbstractState_rhomass_reducing` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_rhomass_reducing', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_rhomass_reducing`, 'returnType') = 'numeric'
attr(`AbstractState_rhomass_reducing`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_rhomass_reducing`) = c("SWIGFunction", class('AbstractState_rhomass_reducing'))

# Start of AbstractState_p_triple

`AbstractState_p_triple` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_p_triple', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_p_triple`, 'returnType') = 'numeric'
attr(`AbstractState_p_triple`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_p_triple`) = c("SWIGFunction", class('AbstractState_p_triple'))

# Start of AbstractState_name

`AbstractState_name` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_name', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_name`, 'returnType') = 'character'
attr(`AbstractState_name`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_name`) = c("SWIGFunction", class('AbstractState_name'))

# Start of AbstractState_dipole_moment

`AbstractState_dipole_moment` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_dipole_moment', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_dipole_moment`, 'returnType') = 'numeric'
attr(`AbstractState_dipole_moment`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_dipole_moment`) = c("SWIGFunction", class('AbstractState_dipole_moment'))

# Start of AbstractState_keyed_output

`AbstractState_keyed_output` = function(self, key, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  key = enumToInteger(key, "_CoolProp__parameters"); 
  
  if(length(key) > 1) {
    warning("using only the first element of key");
  };
  
  ;.Call('R_swig_AbstractState_keyed_output', self, key, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_keyed_output`, 'returnType') = 'numeric'
attr(`AbstractState_keyed_output`, "inputTypes") = c('_p_CoolProp__AbstractState', 'character')
class(`AbstractState_keyed_output`) = c("SWIGFunction", class('AbstractState_keyed_output'))

# Start of AbstractState_trivial_keyed_output

`AbstractState_trivial_keyed_output` = function(self, key, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  key = enumToInteger(key, "_CoolProp__parameters"); 
  
  if(length(key) > 1) {
    warning("using only the first element of key");
  };
  
  ;.Call('R_swig_AbstractState_trivial_keyed_output', self, key, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_trivial_keyed_output`, 'returnType') = 'numeric'
attr(`AbstractState_trivial_keyed_output`, "inputTypes") = c('_p_CoolProp__AbstractState', 'character')
class(`AbstractState_trivial_keyed_output`) = c("SWIGFunction", class('AbstractState_trivial_keyed_output'))

# Start of AbstractState_saturated_liquid_keyed_output

`AbstractState_saturated_liquid_keyed_output` = function(self, key, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  key = enumToInteger(key, "_CoolProp__parameters"); 
  
  if(length(key) > 1) {
    warning("using only the first element of key");
  };
  
  ;.Call('R_swig_AbstractState_saturated_liquid_keyed_output', self, key, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_saturated_liquid_keyed_output`, 'returnType') = 'numeric'
attr(`AbstractState_saturated_liquid_keyed_output`, "inputTypes") = c('_p_CoolProp__AbstractState', 'character')
class(`AbstractState_saturated_liquid_keyed_output`) = c("SWIGFunction", class('AbstractState_saturated_liquid_keyed_output'))

# Start of AbstractState_saturated_vapor_keyed_output

`AbstractState_saturated_vapor_keyed_output` = function(self, key, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  key = enumToInteger(key, "_CoolProp__parameters"); 
  
  if(length(key) > 1) {
    warning("using only the first element of key");
  };
  
  ;.Call('R_swig_AbstractState_saturated_vapor_keyed_output', self, key, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_saturated_vapor_keyed_output`, 'returnType') = 'numeric'
attr(`AbstractState_saturated_vapor_keyed_output`, "inputTypes") = c('_p_CoolProp__AbstractState', 'character')
class(`AbstractState_saturated_vapor_keyed_output`) = c("SWIGFunction", class('AbstractState_saturated_vapor_keyed_output'))

# Start of AbstractState_T

`AbstractState_T` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_T', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_T`, 'returnType') = 'numeric'
attr(`AbstractState_T`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_T`) = c("SWIGFunction", class('AbstractState_T'))

# Start of AbstractState_rhomolar

`AbstractState_rhomolar` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_rhomolar', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_rhomolar`, 'returnType') = 'numeric'
attr(`AbstractState_rhomolar`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_rhomolar`) = c("SWIGFunction", class('AbstractState_rhomolar'))

# Start of AbstractState_rhomass

`AbstractState_rhomass` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_rhomass', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_rhomass`, 'returnType') = 'numeric'
attr(`AbstractState_rhomass`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_rhomass`) = c("SWIGFunction", class('AbstractState_rhomass'))

# Start of AbstractState_p

`AbstractState_p` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_p', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_p`, 'returnType') = 'numeric'
attr(`AbstractState_p`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_p`) = c("SWIGFunction", class('AbstractState_p'))

# Start of AbstractState_Q

`AbstractState_Q` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_Q', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_Q`, 'returnType') = 'numeric'
attr(`AbstractState_Q`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_Q`) = c("SWIGFunction", class('AbstractState_Q'))

# Start of AbstractState_tau

`AbstractState_tau` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_tau', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_tau`, 'returnType') = 'numeric'
attr(`AbstractState_tau`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_tau`) = c("SWIGFunction", class('AbstractState_tau'))

# Start of AbstractState_delta

`AbstractState_delta` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_delta', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_delta`, 'returnType') = 'numeric'
attr(`AbstractState_delta`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_delta`) = c("SWIGFunction", class('AbstractState_delta'))

# Start of AbstractState_molar_mass

`AbstractState_molar_mass` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_molar_mass', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_molar_mass`, 'returnType') = 'numeric'
attr(`AbstractState_molar_mass`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_molar_mass`) = c("SWIGFunction", class('AbstractState_molar_mass'))

# Start of AbstractState_acentric_factor

`AbstractState_acentric_factor` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_acentric_factor', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_acentric_factor`, 'returnType') = 'numeric'
attr(`AbstractState_acentric_factor`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_acentric_factor`) = c("SWIGFunction", class('AbstractState_acentric_factor'))

# Start of AbstractState_gas_constant

`AbstractState_gas_constant` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_gas_constant', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_gas_constant`, 'returnType') = 'numeric'
attr(`AbstractState_gas_constant`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_gas_constant`) = c("SWIGFunction", class('AbstractState_gas_constant'))

# Start of AbstractState_Bvirial

`AbstractState_Bvirial` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_Bvirial', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_Bvirial`, 'returnType') = 'numeric'
attr(`AbstractState_Bvirial`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_Bvirial`) = c("SWIGFunction", class('AbstractState_Bvirial'))

# Start of AbstractState_dBvirial_dT

`AbstractState_dBvirial_dT` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_dBvirial_dT', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_dBvirial_dT`, 'returnType') = 'numeric'
attr(`AbstractState_dBvirial_dT`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_dBvirial_dT`) = c("SWIGFunction", class('AbstractState_dBvirial_dT'))

# Start of AbstractState_Cvirial

`AbstractState_Cvirial` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_Cvirial', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_Cvirial`, 'returnType') = 'numeric'
attr(`AbstractState_Cvirial`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_Cvirial`) = c("SWIGFunction", class('AbstractState_Cvirial'))

# Start of AbstractState_dCvirial_dT

`AbstractState_dCvirial_dT` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_dCvirial_dT', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_dCvirial_dT`, 'returnType') = 'numeric'
attr(`AbstractState_dCvirial_dT`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_dCvirial_dT`) = c("SWIGFunction", class('AbstractState_dCvirial_dT'))

# Start of AbstractState_compressibility_factor

`AbstractState_compressibility_factor` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_compressibility_factor', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_compressibility_factor`, 'returnType') = 'numeric'
attr(`AbstractState_compressibility_factor`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_compressibility_factor`) = c("SWIGFunction", class('AbstractState_compressibility_factor'))

# Start of AbstractState_hmolar

`AbstractState_hmolar` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_hmolar', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_hmolar`, 'returnType') = 'numeric'
attr(`AbstractState_hmolar`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_hmolar`) = c("SWIGFunction", class('AbstractState_hmolar'))

# Start of AbstractState_hmass

`AbstractState_hmass` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_hmass', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_hmass`, 'returnType') = 'numeric'
attr(`AbstractState_hmass`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_hmass`) = c("SWIGFunction", class('AbstractState_hmass'))

# Start of AbstractState_hmolar_excess

`AbstractState_hmolar_excess` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_hmolar_excess', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_hmolar_excess`, 'returnType') = 'numeric'
attr(`AbstractState_hmolar_excess`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_hmolar_excess`) = c("SWIGFunction", class('AbstractState_hmolar_excess'))

# Start of AbstractState_hmass_excess

`AbstractState_hmass_excess` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_hmass_excess', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_hmass_excess`, 'returnType') = 'numeric'
attr(`AbstractState_hmass_excess`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_hmass_excess`) = c("SWIGFunction", class('AbstractState_hmass_excess'))

# Start of AbstractState_smolar

`AbstractState_smolar` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_smolar', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_smolar`, 'returnType') = 'numeric'
attr(`AbstractState_smolar`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_smolar`) = c("SWIGFunction", class('AbstractState_smolar'))

# Start of AbstractState_smass

`AbstractState_smass` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_smass', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_smass`, 'returnType') = 'numeric'
attr(`AbstractState_smass`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_smass`) = c("SWIGFunction", class('AbstractState_smass'))

# Start of AbstractState_smolar_excess

`AbstractState_smolar_excess` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_smolar_excess', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_smolar_excess`, 'returnType') = 'numeric'
attr(`AbstractState_smolar_excess`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_smolar_excess`) = c("SWIGFunction", class('AbstractState_smolar_excess'))

# Start of AbstractState_smass_excess

`AbstractState_smass_excess` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_smass_excess', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_smass_excess`, 'returnType') = 'numeric'
attr(`AbstractState_smass_excess`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_smass_excess`) = c("SWIGFunction", class('AbstractState_smass_excess'))

# Start of AbstractState_umolar

`AbstractState_umolar` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_umolar', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_umolar`, 'returnType') = 'numeric'
attr(`AbstractState_umolar`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_umolar`) = c("SWIGFunction", class('AbstractState_umolar'))

# Start of AbstractState_umass

`AbstractState_umass` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_umass', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_umass`, 'returnType') = 'numeric'
attr(`AbstractState_umass`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_umass`) = c("SWIGFunction", class('AbstractState_umass'))

# Start of AbstractState_umolar_excess

`AbstractState_umolar_excess` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_umolar_excess', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_umolar_excess`, 'returnType') = 'numeric'
attr(`AbstractState_umolar_excess`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_umolar_excess`) = c("SWIGFunction", class('AbstractState_umolar_excess'))

# Start of AbstractState_umass_excess

`AbstractState_umass_excess` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_umass_excess', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_umass_excess`, 'returnType') = 'numeric'
attr(`AbstractState_umass_excess`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_umass_excess`) = c("SWIGFunction", class('AbstractState_umass_excess'))

# Start of AbstractState_cpmolar

`AbstractState_cpmolar` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_cpmolar', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_cpmolar`, 'returnType') = 'numeric'
attr(`AbstractState_cpmolar`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_cpmolar`) = c("SWIGFunction", class('AbstractState_cpmolar'))

# Start of AbstractState_cpmass

`AbstractState_cpmass` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_cpmass', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_cpmass`, 'returnType') = 'numeric'
attr(`AbstractState_cpmass`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_cpmass`) = c("SWIGFunction", class('AbstractState_cpmass'))

# Start of AbstractState_cp0molar

`AbstractState_cp0molar` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_cp0molar', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_cp0molar`, 'returnType') = 'numeric'
attr(`AbstractState_cp0molar`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_cp0molar`) = c("SWIGFunction", class('AbstractState_cp0molar'))

# Start of AbstractState_cp0mass

`AbstractState_cp0mass` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_cp0mass', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_cp0mass`, 'returnType') = 'numeric'
attr(`AbstractState_cp0mass`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_cp0mass`) = c("SWIGFunction", class('AbstractState_cp0mass'))

# Start of AbstractState_cvmolar

`AbstractState_cvmolar` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_cvmolar', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_cvmolar`, 'returnType') = 'numeric'
attr(`AbstractState_cvmolar`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_cvmolar`) = c("SWIGFunction", class('AbstractState_cvmolar'))

# Start of AbstractState_cvmass

`AbstractState_cvmass` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_cvmass', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_cvmass`, 'returnType') = 'numeric'
attr(`AbstractState_cvmass`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_cvmass`) = c("SWIGFunction", class('AbstractState_cvmass'))

# Start of AbstractState_gibbsmolar

`AbstractState_gibbsmolar` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_gibbsmolar', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_gibbsmolar`, 'returnType') = 'numeric'
attr(`AbstractState_gibbsmolar`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_gibbsmolar`) = c("SWIGFunction", class('AbstractState_gibbsmolar'))

# Start of AbstractState_gibbsmass

`AbstractState_gibbsmass` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_gibbsmass', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_gibbsmass`, 'returnType') = 'numeric'
attr(`AbstractState_gibbsmass`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_gibbsmass`) = c("SWIGFunction", class('AbstractState_gibbsmass'))

# Start of AbstractState_gibbsmolar_excess

`AbstractState_gibbsmolar_excess` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_gibbsmolar_excess', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_gibbsmolar_excess`, 'returnType') = 'numeric'
attr(`AbstractState_gibbsmolar_excess`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_gibbsmolar_excess`) = c("SWIGFunction", class('AbstractState_gibbsmolar_excess'))

# Start of AbstractState_gibbsmass_excess

`AbstractState_gibbsmass_excess` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_gibbsmass_excess', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_gibbsmass_excess`, 'returnType') = 'numeric'
attr(`AbstractState_gibbsmass_excess`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_gibbsmass_excess`) = c("SWIGFunction", class('AbstractState_gibbsmass_excess'))

# Start of AbstractState_helmholtzmolar

`AbstractState_helmholtzmolar` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_helmholtzmolar', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_helmholtzmolar`, 'returnType') = 'numeric'
attr(`AbstractState_helmholtzmolar`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_helmholtzmolar`) = c("SWIGFunction", class('AbstractState_helmholtzmolar'))

# Start of AbstractState_helmholtzmass

`AbstractState_helmholtzmass` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_helmholtzmass', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_helmholtzmass`, 'returnType') = 'numeric'
attr(`AbstractState_helmholtzmass`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_helmholtzmass`) = c("SWIGFunction", class('AbstractState_helmholtzmass'))

# Start of AbstractState_helmholtzmolar_excess

`AbstractState_helmholtzmolar_excess` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_helmholtzmolar_excess', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_helmholtzmolar_excess`, 'returnType') = 'numeric'
attr(`AbstractState_helmholtzmolar_excess`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_helmholtzmolar_excess`) = c("SWIGFunction", class('AbstractState_helmholtzmolar_excess'))

# Start of AbstractState_helmholtzmass_excess

`AbstractState_helmholtzmass_excess` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_helmholtzmass_excess', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_helmholtzmass_excess`, 'returnType') = 'numeric'
attr(`AbstractState_helmholtzmass_excess`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_helmholtzmass_excess`) = c("SWIGFunction", class('AbstractState_helmholtzmass_excess'))

# Start of AbstractState_volumemolar_excess

`AbstractState_volumemolar_excess` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_volumemolar_excess', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_volumemolar_excess`, 'returnType') = 'numeric'
attr(`AbstractState_volumemolar_excess`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_volumemolar_excess`) = c("SWIGFunction", class('AbstractState_volumemolar_excess'))

# Start of AbstractState_volumemass_excess

`AbstractState_volumemass_excess` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_volumemass_excess', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_volumemass_excess`, 'returnType') = 'numeric'
attr(`AbstractState_volumemass_excess`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_volumemass_excess`) = c("SWIGFunction", class('AbstractState_volumemass_excess'))

# Start of AbstractState_speed_sound

`AbstractState_speed_sound` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_speed_sound', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_speed_sound`, 'returnType') = 'numeric'
attr(`AbstractState_speed_sound`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_speed_sound`) = c("SWIGFunction", class('AbstractState_speed_sound'))

# Start of AbstractState_isothermal_compressibility

`AbstractState_isothermal_compressibility` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_isothermal_compressibility', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_isothermal_compressibility`, 'returnType') = 'numeric'
attr(`AbstractState_isothermal_compressibility`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_isothermal_compressibility`) = c("SWIGFunction", class('AbstractState_isothermal_compressibility'))

# Start of AbstractState_isobaric_expansion_coefficient

`AbstractState_isobaric_expansion_coefficient` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_isobaric_expansion_coefficient', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_isobaric_expansion_coefficient`, 'returnType') = 'numeric'
attr(`AbstractState_isobaric_expansion_coefficient`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_isobaric_expansion_coefficient`) = c("SWIGFunction", class('AbstractState_isobaric_expansion_coefficient'))

# Start of AbstractState_fugacity_coefficient

`AbstractState_fugacity_coefficient` = function(self, i, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_AbstractState_fugacity_coefficient', self, i, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_fugacity_coefficient`, 'returnType') = 'numeric'
attr(`AbstractState_fugacity_coefficient`, "inputTypes") = c('_p_CoolProp__AbstractState', 'integer')
class(`AbstractState_fugacity_coefficient`) = c("SWIGFunction", class('AbstractState_fugacity_coefficient'))

# Start of AbstractState_fugacity

`AbstractState_fugacity` = function(self, i, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_AbstractState_fugacity', self, i, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_fugacity`, 'returnType') = 'numeric'
attr(`AbstractState_fugacity`, "inputTypes") = c('_p_CoolProp__AbstractState', 'integer')
class(`AbstractState_fugacity`) = c("SWIGFunction", class('AbstractState_fugacity'))

# Start of AbstractState_chemical_potential

`AbstractState_chemical_potential` = function(self, i, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_AbstractState_chemical_potential', self, i, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_chemical_potential`, 'returnType') = 'numeric'
attr(`AbstractState_chemical_potential`, "inputTypes") = c('_p_CoolProp__AbstractState', 'integer')
class(`AbstractState_chemical_potential`) = c("SWIGFunction", class('AbstractState_chemical_potential'))

# Start of AbstractState_fundamental_derivative_of_gas_dynamics

`AbstractState_fundamental_derivative_of_gas_dynamics` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_fundamental_derivative_of_gas_dynamics', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_fundamental_derivative_of_gas_dynamics`, 'returnType') = 'numeric'
attr(`AbstractState_fundamental_derivative_of_gas_dynamics`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_fundamental_derivative_of_gas_dynamics`) = c("SWIGFunction", class('AbstractState_fundamental_derivative_of_gas_dynamics'))

# Start of AbstractState_PIP

`AbstractState_PIP` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_PIP', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_PIP`, 'returnType') = 'numeric'
attr(`AbstractState_PIP`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_PIP`) = c("SWIGFunction", class('AbstractState_PIP'))

# Start of AbstractState_true_critical_point

`AbstractState_true_critical_point` = function(self, T, rho)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  
  ;.Call('R_swig_AbstractState_true_critical_point', self, T, rho, PACKAGE='CoolProp');
  
}

attr(`AbstractState_true_critical_point`, 'returnType') = 'void'
attr(`AbstractState_true_critical_point`, "inputTypes") = c('_p_CoolProp__AbstractState', 'numeric', 'numeric')
class(`AbstractState_true_critical_point`) = c("SWIGFunction", class('AbstractState_true_critical_point'))

# Start of AbstractState_ideal_curve

`AbstractState_ideal_curve` = function(self, type, T, p)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  type = as(type, "character"); 
  if (inherits(T, "ExternalReference")) T = slot(T,"ref") 
  if (inherits(p, "ExternalReference")) p = slot(p,"ref") 
  ;.Call('R_swig_AbstractState_ideal_curve', self, type, T, p, PACKAGE='CoolProp');
  
}

attr(`AbstractState_ideal_curve`, 'returnType') = 'void'
attr(`AbstractState_ideal_curve`, "inputTypes") = c('_p_CoolProp__AbstractState', 'character', '_p_std__vectorT_double_std__allocatorT_double_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`AbstractState_ideal_curve`) = c("SWIGFunction", class('AbstractState_ideal_curve'))

# Start of AbstractState_first_partial_deriv

`AbstractState_first_partial_deriv` = function(self, Of, Wrt, Constant, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  Of = enumToInteger(Of, "_CoolProp__parameters"); 
  
  if(length(Of) > 1) {
    warning("using only the first element of Of");
  };
  
  Wrt = enumToInteger(Wrt, "_CoolProp__parameters"); 
  
  if(length(Wrt) > 1) {
    warning("using only the first element of Wrt");
  };
  
  Constant = enumToInteger(Constant, "_CoolProp__parameters"); 
  
  if(length(Constant) > 1) {
    warning("using only the first element of Constant");
  };
  
  ;.Call('R_swig_AbstractState_first_partial_deriv', self, Of, Wrt, Constant, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_first_partial_deriv`, 'returnType') = 'numeric'
attr(`AbstractState_first_partial_deriv`, "inputTypes") = c('_p_CoolProp__AbstractState', 'character', 'character', 'character')
class(`AbstractState_first_partial_deriv`) = c("SWIGFunction", class('AbstractState_first_partial_deriv'))

# Start of AbstractState_second_partial_deriv

`AbstractState_second_partial_deriv` = function(self, Of1, Wrt1, Constant1, Wrt2, Constant2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  Of1 = enumToInteger(Of1, "_CoolProp__parameters"); 
  
  if(length(Of1) > 1) {
    warning("using only the first element of Of1");
  };
  
  Wrt1 = enumToInteger(Wrt1, "_CoolProp__parameters"); 
  
  if(length(Wrt1) > 1) {
    warning("using only the first element of Wrt1");
  };
  
  Constant1 = enumToInteger(Constant1, "_CoolProp__parameters"); 
  
  if(length(Constant1) > 1) {
    warning("using only the first element of Constant1");
  };
  
  Wrt2 = enumToInteger(Wrt2, "_CoolProp__parameters"); 
  
  if(length(Wrt2) > 1) {
    warning("using only the first element of Wrt2");
  };
  
  Constant2 = enumToInteger(Constant2, "_CoolProp__parameters"); 
  
  if(length(Constant2) > 1) {
    warning("using only the first element of Constant2");
  };
  
  ;.Call('R_swig_AbstractState_second_partial_deriv', self, Of1, Wrt1, Constant1, Wrt2, Constant2, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_second_partial_deriv`, 'returnType') = 'numeric'
attr(`AbstractState_second_partial_deriv`, "inputTypes") = c('_p_CoolProp__AbstractState', 'character', 'character', 'character', 'character', 'character')
class(`AbstractState_second_partial_deriv`) = c("SWIGFunction", class('AbstractState_second_partial_deriv'))

# Start of AbstractState_first_saturation_deriv

`AbstractState_first_saturation_deriv` = function(self, Of1, Wrt1, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  Of1 = enumToInteger(Of1, "_CoolProp__parameters"); 
  
  if(length(Of1) > 1) {
    warning("using only the first element of Of1");
  };
  
  Wrt1 = enumToInteger(Wrt1, "_CoolProp__parameters"); 
  
  if(length(Wrt1) > 1) {
    warning("using only the first element of Wrt1");
  };
  
  ;.Call('R_swig_AbstractState_first_saturation_deriv', self, Of1, Wrt1, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_first_saturation_deriv`, 'returnType') = 'numeric'
attr(`AbstractState_first_saturation_deriv`, "inputTypes") = c('_p_CoolProp__AbstractState', 'character', 'character')
class(`AbstractState_first_saturation_deriv`) = c("SWIGFunction", class('AbstractState_first_saturation_deriv'))

# Start of AbstractState_second_saturation_deriv

`AbstractState_second_saturation_deriv` = function(self, Of1, Wrt1, Wrt2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  Of1 = enumToInteger(Of1, "_CoolProp__parameters"); 
  
  if(length(Of1) > 1) {
    warning("using only the first element of Of1");
  };
  
  Wrt1 = enumToInteger(Wrt1, "_CoolProp__parameters"); 
  
  if(length(Wrt1) > 1) {
    warning("using only the first element of Wrt1");
  };
  
  Wrt2 = enumToInteger(Wrt2, "_CoolProp__parameters"); 
  
  if(length(Wrt2) > 1) {
    warning("using only the first element of Wrt2");
  };
  
  ;.Call('R_swig_AbstractState_second_saturation_deriv', self, Of1, Wrt1, Wrt2, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_second_saturation_deriv`, 'returnType') = 'numeric'
attr(`AbstractState_second_saturation_deriv`, "inputTypes") = c('_p_CoolProp__AbstractState', 'character', 'character', 'character')
class(`AbstractState_second_saturation_deriv`) = c("SWIGFunction", class('AbstractState_second_saturation_deriv'))

# Start of AbstractState_first_two_phase_deriv

`AbstractState_first_two_phase_deriv` = function(self, Of, Wrt, Constant, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  Of = enumToInteger(Of, "_CoolProp__parameters"); 
  
  if(length(Of) > 1) {
    warning("using only the first element of Of");
  };
  
  Wrt = enumToInteger(Wrt, "_CoolProp__parameters"); 
  
  if(length(Wrt) > 1) {
    warning("using only the first element of Wrt");
  };
  
  Constant = enumToInteger(Constant, "_CoolProp__parameters"); 
  
  if(length(Constant) > 1) {
    warning("using only the first element of Constant");
  };
  
  ;.Call('R_swig_AbstractState_first_two_phase_deriv', self, Of, Wrt, Constant, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_first_two_phase_deriv`, 'returnType') = 'numeric'
attr(`AbstractState_first_two_phase_deriv`, "inputTypes") = c('_p_CoolProp__AbstractState', 'character', 'character', 'character')
class(`AbstractState_first_two_phase_deriv`) = c("SWIGFunction", class('AbstractState_first_two_phase_deriv'))

# Start of AbstractState_second_two_phase_deriv

`AbstractState_second_two_phase_deriv` = function(self, Of, Wrt1, Constant1, Wrt2, Constant2, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  Of = enumToInteger(Of, "_CoolProp__parameters"); 
  
  if(length(Of) > 1) {
    warning("using only the first element of Of");
  };
  
  Wrt1 = enumToInteger(Wrt1, "_CoolProp__parameters"); 
  
  if(length(Wrt1) > 1) {
    warning("using only the first element of Wrt1");
  };
  
  Constant1 = enumToInteger(Constant1, "_CoolProp__parameters"); 
  
  if(length(Constant1) > 1) {
    warning("using only the first element of Constant1");
  };
  
  Wrt2 = enumToInteger(Wrt2, "_CoolProp__parameters"); 
  
  if(length(Wrt2) > 1) {
    warning("using only the first element of Wrt2");
  };
  
  Constant2 = enumToInteger(Constant2, "_CoolProp__parameters"); 
  
  if(length(Constant2) > 1) {
    warning("using only the first element of Constant2");
  };
  
  ;.Call('R_swig_AbstractState_second_two_phase_deriv', self, Of, Wrt1, Constant1, Wrt2, Constant2, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_second_two_phase_deriv`, 'returnType') = 'numeric'
attr(`AbstractState_second_two_phase_deriv`, "inputTypes") = c('_p_CoolProp__AbstractState', 'character', 'character', 'character', 'character', 'character')
class(`AbstractState_second_two_phase_deriv`) = c("SWIGFunction", class('AbstractState_second_two_phase_deriv'))

# Start of AbstractState_first_two_phase_deriv_splined

`AbstractState_first_two_phase_deriv_splined` = function(self, Of, Wrt, Constant, x_end, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  Of = enumToInteger(Of, "_CoolProp__parameters"); 
  
  if(length(Of) > 1) {
    warning("using only the first element of Of");
  };
  
  Wrt = enumToInteger(Wrt, "_CoolProp__parameters"); 
  
  if(length(Wrt) > 1) {
    warning("using only the first element of Wrt");
  };
  
  Constant = enumToInteger(Constant, "_CoolProp__parameters"); 
  
  if(length(Constant) > 1) {
    warning("using only the first element of Constant");
  };
  
  
  ;.Call('R_swig_AbstractState_first_two_phase_deriv_splined', self, Of, Wrt, Constant, x_end, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_first_two_phase_deriv_splined`, 'returnType') = 'numeric'
attr(`AbstractState_first_two_phase_deriv_splined`, "inputTypes") = c('_p_CoolProp__AbstractState', 'character', 'character', 'character', 'numeric')
class(`AbstractState_first_two_phase_deriv_splined`) = c("SWIGFunction", class('AbstractState_first_two_phase_deriv_splined'))

# Start of AbstractState_build_phase_envelope

`AbstractState_build_phase_envelope__SWIG_0` = function(self, type)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  type = as(type, "character"); 
  ;.Call('R_swig_AbstractState_build_phase_envelope__SWIG_0', self, type, PACKAGE='CoolProp');
  
}

attr(`AbstractState_build_phase_envelope__SWIG_0`, 'returnType') = 'void'
attr(`AbstractState_build_phase_envelope__SWIG_0`, "inputTypes") = c('_p_CoolProp__AbstractState', 'character')
class(`AbstractState_build_phase_envelope__SWIG_0`) = c("SWIGFunction", class('AbstractState_build_phase_envelope__SWIG_0'))

# Start of AbstractState_build_phase_envelope

`AbstractState_build_phase_envelope__SWIG_1` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_build_phase_envelope__SWIG_1', self, PACKAGE='CoolProp');
  
}

attr(`AbstractState_build_phase_envelope__SWIG_1`, 'returnType') = 'void'
attr(`AbstractState_build_phase_envelope__SWIG_1`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_build_phase_envelope__SWIG_1`) = c("SWIGFunction", class('AbstractState_build_phase_envelope__SWIG_1'))

`AbstractState_build_phase_envelope` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (extends(argtypes[1], '_p_CoolProp__AbstractState')) {
      f <- AbstractState_build_phase_envelope__SWIG_1; 
    }
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_CoolProp__AbstractState') && is.character(argv[[2]]) && length(argv[[2]]) == 1) {
      f <- AbstractState_build_phase_envelope__SWIG_0; 
    }
  } else {
    stop("cannot find overloaded function for AbstractState_build_phase_envelope with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of AbstractState_get_phase_envelope_data

`AbstractState_get_phase_envelope_data` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_AbstractState_get_phase_envelope_data', self, as.logical(.copy), PACKAGE='CoolProp');
  ans <- new("_p_CoolProp__PhaseEnvelopeData", ref=ans) ;
  
  ans
  
}

attr(`AbstractState_get_phase_envelope_data`, 'returnType') = '_p_CoolProp__PhaseEnvelopeData'
attr(`AbstractState_get_phase_envelope_data`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_get_phase_envelope_data`) = c("SWIGFunction", class('AbstractState_get_phase_envelope_data'))

# Start of AbstractState_has_melting_line

`AbstractState_has_melting_line` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_has_melting_line', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_has_melting_line`, 'returnType') = 'logical'
attr(`AbstractState_has_melting_line`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_has_melting_line`) = c("SWIGFunction", class('AbstractState_has_melting_line'))

# Start of AbstractState_melting_line

`AbstractState_melting_line` = function(self, param, given, value, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  param = as.integer(param);
  
  if(length(param) > 1) {
    warning("using only the first element of param");
  };
  
  given = as.integer(given);
  
  if(length(given) > 1) {
    warning("using only the first element of given");
  };
  
  
  ;.Call('R_swig_AbstractState_melting_line', self, param, given, value, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_melting_line`, 'returnType') = 'numeric'
attr(`AbstractState_melting_line`, "inputTypes") = c('_p_CoolProp__AbstractState', 'integer', 'integer', 'numeric')
class(`AbstractState_melting_line`) = c("SWIGFunction", class('AbstractState_melting_line'))

# Start of AbstractState_saturation_ancillary

`AbstractState_saturation_ancillary` = function(self, param, Q, given, value, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  param = enumToInteger(param, "_CoolProp__parameters"); 
  
  if(length(param) > 1) {
    warning("using only the first element of param");
  };
  
  Q = as.integer(Q);
  
  if(length(Q) > 1) {
    warning("using only the first element of Q");
  };
  
  given = enumToInteger(given, "_CoolProp__parameters"); 
  
  if(length(given) > 1) {
    warning("using only the first element of given");
  };
  
  
  ;.Call('R_swig_AbstractState_saturation_ancillary', self, param, Q, given, value, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_saturation_ancillary`, 'returnType') = 'numeric'
attr(`AbstractState_saturation_ancillary`, "inputTypes") = c('_p_CoolProp__AbstractState', 'character', 'integer', 'character', 'numeric')
class(`AbstractState_saturation_ancillary`) = c("SWIGFunction", class('AbstractState_saturation_ancillary'))

# Start of AbstractState_viscosity

`AbstractState_viscosity` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_viscosity', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_viscosity`, 'returnType') = 'numeric'
attr(`AbstractState_viscosity`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_viscosity`) = c("SWIGFunction", class('AbstractState_viscosity'))

# Start of AbstractState_viscosity_contributions

`AbstractState_viscosity_contributions` = function(self, dilute, initial_density, residual, critical)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(dilute, "ExternalReference")) dilute = slot(dilute,"ref") 
  if (inherits(initial_density, "ExternalReference")) initial_density = slot(initial_density,"ref") 
  if (inherits(residual, "ExternalReference")) residual = slot(residual,"ref") 
  if (inherits(critical, "ExternalReference")) critical = slot(critical,"ref") 
  ;.Call('R_swig_AbstractState_viscosity_contributions', self, dilute, initial_density, residual, critical, PACKAGE='CoolProp');
  
}

attr(`AbstractState_viscosity_contributions`, 'returnType') = 'void'
attr(`AbstractState_viscosity_contributions`, "inputTypes") = c('_p_CoolProp__AbstractState', '_p_CoolPropDbl', '_p_CoolPropDbl', '_p_CoolPropDbl', '_p_CoolPropDbl')
class(`AbstractState_viscosity_contributions`) = c("SWIGFunction", class('AbstractState_viscosity_contributions'))

# Start of AbstractState_conductivity

`AbstractState_conductivity` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_conductivity', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_conductivity`, 'returnType') = 'numeric'
attr(`AbstractState_conductivity`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_conductivity`) = c("SWIGFunction", class('AbstractState_conductivity'))

# Start of AbstractState_conductivity_contributions

`AbstractState_conductivity_contributions` = function(self, dilute, initial_density, residual, critical)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(dilute, "ExternalReference")) dilute = slot(dilute,"ref") 
  if (inherits(initial_density, "ExternalReference")) initial_density = slot(initial_density,"ref") 
  if (inherits(residual, "ExternalReference")) residual = slot(residual,"ref") 
  if (inherits(critical, "ExternalReference")) critical = slot(critical,"ref") 
  ;.Call('R_swig_AbstractState_conductivity_contributions', self, dilute, initial_density, residual, critical, PACKAGE='CoolProp');
  
}

attr(`AbstractState_conductivity_contributions`, 'returnType') = 'void'
attr(`AbstractState_conductivity_contributions`, "inputTypes") = c('_p_CoolProp__AbstractState', '_p_CoolPropDbl', '_p_CoolPropDbl', '_p_CoolPropDbl', '_p_CoolPropDbl')
class(`AbstractState_conductivity_contributions`) = c("SWIGFunction", class('AbstractState_conductivity_contributions'))

# Start of AbstractState_surface_tension

`AbstractState_surface_tension` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_surface_tension', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_surface_tension`, 'returnType') = 'numeric'
attr(`AbstractState_surface_tension`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_surface_tension`) = c("SWIGFunction", class('AbstractState_surface_tension'))

# Start of AbstractState_Prandtl

`AbstractState_Prandtl` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_Prandtl', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_Prandtl`, 'returnType') = 'numeric'
attr(`AbstractState_Prandtl`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_Prandtl`) = c("SWIGFunction", class('AbstractState_Prandtl'))

# Start of AbstractState_conformal_state

`AbstractState_conformal_state` = function(self, reference_fluid, T, rhomolar)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  reference_fluid = as(reference_fluid, "character"); 
  if (inherits(T, "ExternalReference")) T = slot(T,"ref") 
  if (inherits(rhomolar, "ExternalReference")) rhomolar = slot(rhomolar,"ref") 
  ;.Call('R_swig_AbstractState_conformal_state', self, reference_fluid, T, rhomolar, PACKAGE='CoolProp');
  
}

attr(`AbstractState_conformal_state`, 'returnType') = 'void'
attr(`AbstractState_conformal_state`, "inputTypes") = c('_p_CoolProp__AbstractState', 'character', '_p_CoolPropDbl', '_p_CoolPropDbl')
class(`AbstractState_conformal_state`) = c("SWIGFunction", class('AbstractState_conformal_state'))

# Start of AbstractState_change_EOS

`AbstractState_change_EOS` = function(self, i, EOS_name)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  EOS_name = as(EOS_name, "character"); 
  ;.Call('R_swig_AbstractState_change_EOS', self, i, EOS_name, PACKAGE='CoolProp');
  
}

attr(`AbstractState_change_EOS`, 'returnType') = 'void'
attr(`AbstractState_change_EOS`, "inputTypes") = c('_p_CoolProp__AbstractState', 'integer', 'character')
class(`AbstractState_change_EOS`) = c("SWIGFunction", class('AbstractState_change_EOS'))

# Start of AbstractState_alpha0

`AbstractState_alpha0` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_alpha0', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_alpha0`, 'returnType') = 'numeric'
attr(`AbstractState_alpha0`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_alpha0`) = c("SWIGFunction", class('AbstractState_alpha0'))

# Start of AbstractState_dalpha0_dDelta

`AbstractState_dalpha0_dDelta` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_dalpha0_dDelta', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_dalpha0_dDelta`, 'returnType') = 'numeric'
attr(`AbstractState_dalpha0_dDelta`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_dalpha0_dDelta`) = c("SWIGFunction", class('AbstractState_dalpha0_dDelta'))

# Start of AbstractState_dalpha0_dTau

`AbstractState_dalpha0_dTau` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_dalpha0_dTau', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_dalpha0_dTau`, 'returnType') = 'numeric'
attr(`AbstractState_dalpha0_dTau`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_dalpha0_dTau`) = c("SWIGFunction", class('AbstractState_dalpha0_dTau'))

# Start of AbstractState_d2alpha0_dDelta2

`AbstractState_d2alpha0_dDelta2` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_d2alpha0_dDelta2', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_d2alpha0_dDelta2`, 'returnType') = 'numeric'
attr(`AbstractState_d2alpha0_dDelta2`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_d2alpha0_dDelta2`) = c("SWIGFunction", class('AbstractState_d2alpha0_dDelta2'))

# Start of AbstractState_d2alpha0_dDelta_dTau

`AbstractState_d2alpha0_dDelta_dTau` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_d2alpha0_dDelta_dTau', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_d2alpha0_dDelta_dTau`, 'returnType') = 'numeric'
attr(`AbstractState_d2alpha0_dDelta_dTau`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_d2alpha0_dDelta_dTau`) = c("SWIGFunction", class('AbstractState_d2alpha0_dDelta_dTau'))

# Start of AbstractState_d2alpha0_dTau2

`AbstractState_d2alpha0_dTau2` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_d2alpha0_dTau2', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_d2alpha0_dTau2`, 'returnType') = 'numeric'
attr(`AbstractState_d2alpha0_dTau2`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_d2alpha0_dTau2`) = c("SWIGFunction", class('AbstractState_d2alpha0_dTau2'))

# Start of AbstractState_d3alpha0_dTau3

`AbstractState_d3alpha0_dTau3` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_d3alpha0_dTau3', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_d3alpha0_dTau3`, 'returnType') = 'numeric'
attr(`AbstractState_d3alpha0_dTau3`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_d3alpha0_dTau3`) = c("SWIGFunction", class('AbstractState_d3alpha0_dTau3'))

# Start of AbstractState_d3alpha0_dDelta_dTau2

`AbstractState_d3alpha0_dDelta_dTau2` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_d3alpha0_dDelta_dTau2', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_d3alpha0_dDelta_dTau2`, 'returnType') = 'numeric'
attr(`AbstractState_d3alpha0_dDelta_dTau2`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_d3alpha0_dDelta_dTau2`) = c("SWIGFunction", class('AbstractState_d3alpha0_dDelta_dTau2'))

# Start of AbstractState_d3alpha0_dDelta2_dTau

`AbstractState_d3alpha0_dDelta2_dTau` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_d3alpha0_dDelta2_dTau', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_d3alpha0_dDelta2_dTau`, 'returnType') = 'numeric'
attr(`AbstractState_d3alpha0_dDelta2_dTau`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_d3alpha0_dDelta2_dTau`) = c("SWIGFunction", class('AbstractState_d3alpha0_dDelta2_dTau'))

# Start of AbstractState_d3alpha0_dDelta3

`AbstractState_d3alpha0_dDelta3` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_d3alpha0_dDelta3', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_d3alpha0_dDelta3`, 'returnType') = 'numeric'
attr(`AbstractState_d3alpha0_dDelta3`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_d3alpha0_dDelta3`) = c("SWIGFunction", class('AbstractState_d3alpha0_dDelta3'))

# Start of AbstractState_alphar

`AbstractState_alphar` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_alphar', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_alphar`, 'returnType') = 'numeric'
attr(`AbstractState_alphar`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_alphar`) = c("SWIGFunction", class('AbstractState_alphar'))

# Start of AbstractState_dalphar_dDelta

`AbstractState_dalphar_dDelta` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_dalphar_dDelta', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_dalphar_dDelta`, 'returnType') = 'numeric'
attr(`AbstractState_dalphar_dDelta`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_dalphar_dDelta`) = c("SWIGFunction", class('AbstractState_dalphar_dDelta'))

# Start of AbstractState_dalphar_dTau

`AbstractState_dalphar_dTau` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_dalphar_dTau', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_dalphar_dTau`, 'returnType') = 'numeric'
attr(`AbstractState_dalphar_dTau`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_dalphar_dTau`) = c("SWIGFunction", class('AbstractState_dalphar_dTau'))

# Start of AbstractState_d2alphar_dDelta2

`AbstractState_d2alphar_dDelta2` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_d2alphar_dDelta2', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_d2alphar_dDelta2`, 'returnType') = 'numeric'
attr(`AbstractState_d2alphar_dDelta2`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_d2alphar_dDelta2`) = c("SWIGFunction", class('AbstractState_d2alphar_dDelta2'))

# Start of AbstractState_d2alphar_dDelta_dTau

`AbstractState_d2alphar_dDelta_dTau` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_d2alphar_dDelta_dTau', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_d2alphar_dDelta_dTau`, 'returnType') = 'numeric'
attr(`AbstractState_d2alphar_dDelta_dTau`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_d2alphar_dDelta_dTau`) = c("SWIGFunction", class('AbstractState_d2alphar_dDelta_dTau'))

# Start of AbstractState_d2alphar_dTau2

`AbstractState_d2alphar_dTau2` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_d2alphar_dTau2', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_d2alphar_dTau2`, 'returnType') = 'numeric'
attr(`AbstractState_d2alphar_dTau2`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_d2alphar_dTau2`) = c("SWIGFunction", class('AbstractState_d2alphar_dTau2'))

# Start of AbstractState_d3alphar_dDelta3

`AbstractState_d3alphar_dDelta3` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_d3alphar_dDelta3', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_d3alphar_dDelta3`, 'returnType') = 'numeric'
attr(`AbstractState_d3alphar_dDelta3`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_d3alphar_dDelta3`) = c("SWIGFunction", class('AbstractState_d3alphar_dDelta3'))

# Start of AbstractState_d3alphar_dDelta2_dTau

`AbstractState_d3alphar_dDelta2_dTau` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_d3alphar_dDelta2_dTau', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_d3alphar_dDelta2_dTau`, 'returnType') = 'numeric'
attr(`AbstractState_d3alphar_dDelta2_dTau`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_d3alphar_dDelta2_dTau`) = c("SWIGFunction", class('AbstractState_d3alphar_dDelta2_dTau'))

# Start of AbstractState_d3alphar_dDelta_dTau2

`AbstractState_d3alphar_dDelta_dTau2` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_d3alphar_dDelta_dTau2', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_d3alphar_dDelta_dTau2`, 'returnType') = 'numeric'
attr(`AbstractState_d3alphar_dDelta_dTau2`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_d3alphar_dDelta_dTau2`) = c("SWIGFunction", class('AbstractState_d3alphar_dDelta_dTau2'))

# Start of AbstractState_d3alphar_dTau3

`AbstractState_d3alphar_dTau3` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_d3alphar_dTau3', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_d3alphar_dTau3`, 'returnType') = 'numeric'
attr(`AbstractState_d3alphar_dTau3`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_d3alphar_dTau3`) = c("SWIGFunction", class('AbstractState_d3alphar_dTau3'))

# Start of AbstractState_d4alphar_dDelta4

`AbstractState_d4alphar_dDelta4` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_d4alphar_dDelta4', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_d4alphar_dDelta4`, 'returnType') = 'numeric'
attr(`AbstractState_d4alphar_dDelta4`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_d4alphar_dDelta4`) = c("SWIGFunction", class('AbstractState_d4alphar_dDelta4'))

# Start of AbstractState_d4alphar_dDelta3_dTau

`AbstractState_d4alphar_dDelta3_dTau` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_d4alphar_dDelta3_dTau', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_d4alphar_dDelta3_dTau`, 'returnType') = 'numeric'
attr(`AbstractState_d4alphar_dDelta3_dTau`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_d4alphar_dDelta3_dTau`) = c("SWIGFunction", class('AbstractState_d4alphar_dDelta3_dTau'))

# Start of AbstractState_d4alphar_dDelta2_dTau2

`AbstractState_d4alphar_dDelta2_dTau2` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_d4alphar_dDelta2_dTau2', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_d4alphar_dDelta2_dTau2`, 'returnType') = 'numeric'
attr(`AbstractState_d4alphar_dDelta2_dTau2`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_d4alphar_dDelta2_dTau2`) = c("SWIGFunction", class('AbstractState_d4alphar_dDelta2_dTau2'))

# Start of AbstractState_d4alphar_dDelta_dTau3

`AbstractState_d4alphar_dDelta_dTau3` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_d4alphar_dDelta_dTau3', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_d4alphar_dDelta_dTau3`, 'returnType') = 'numeric'
attr(`AbstractState_d4alphar_dDelta_dTau3`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_d4alphar_dDelta_dTau3`) = c("SWIGFunction", class('AbstractState_d4alphar_dDelta_dTau3'))

# Start of AbstractState_d4alphar_dTau4

`AbstractState_d4alphar_dTau4` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_AbstractState_d4alphar_dTau4', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`AbstractState_d4alphar_dTau4`, 'returnType') = 'numeric'
attr(`AbstractState_d4alphar_dTau4`, "inputTypes") = c('_p_CoolProp__AbstractState')
class(`AbstractState_d4alphar_dTau4`) = c("SWIGFunction", class('AbstractState_d4alphar_dTau4'))

# Start of accessor method for CoolProp::AbstractState
setMethod('$', '_p_CoolProp__AbstractState', function(x, name)

{
  accessorFuns = list('set_T' = AbstractState_set_T, 'backend_name' = AbstractState_backend_name, 'using_mole_fractions' = AbstractState_using_mole_fractions, 'using_mass_fractions' = AbstractState_using_mass_fractions, 'using_volu_fractions' = AbstractState_using_volu_fractions, 'set_mole_fractions' = AbstractState_set_mole_fractions, 'set_mass_fractions' = AbstractState_set_mass_fractions, 'set_volu_fractions' = AbstractState_set_volu_fractions, 'mole_fractions_liquid' = AbstractState_mole_fractions_liquid, 'mole_fractions_vapor' = AbstractState_mole_fractions_vapor, 'get_mole_fractions' = AbstractState_get_mole_fractions, 'get_mass_fractions' = AbstractState_get_mass_fractions, 'update' = AbstractState_update, 'update_with_guesses' = AbstractState_update_with_guesses, 'available_in_high_level' = AbstractState_available_in_high_level, 'fluid_param_string' = AbstractState_fluid_param_string, 'fluid_names' = AbstractState_fluid_names, 'set_binary_interaction_double' = AbstractState_set_binary_interaction_double, 'set_binary_interaction_string' = AbstractState_set_binary_interaction_string, 'get_binary_interaction_double' = AbstractState_get_binary_interaction_double, 'get_binary_interaction_string' = AbstractState_get_binary_interaction_string, 'apply_simple_mixing_rule' = AbstractState_apply_simple_mixing_rule, 'set_fluid_parameter_double' = AbstractState_set_fluid_parameter_double, 'clear' = AbstractState_clear, 'get_reducing_state' = AbstractState_get_reducing_state, 'get_state' = AbstractState_get_state, 'Tmin' = AbstractState_Tmin, 'Tmax' = AbstractState_Tmax, 'pmax' = AbstractState_pmax, 'Ttriple' = AbstractState_Ttriple, 'phase' = AbstractState_phase, 'specify_phase' = AbstractState_specify_phase, 'unspecify_phase' = AbstractState_unspecify_phase, 'T_critical' = AbstractState_T_critical, 'p_critical' = AbstractState_p_critical, 'rhomolar_critical' = AbstractState_rhomolar_critical, 'rhomass_critical' = AbstractState_rhomass_critical, 'all_critical_points' = AbstractState_all_critical_points, 'build_spinodal' = AbstractState_build_spinodal, 'get_spinodal_data' = AbstractState_get_spinodal_data, 'criticality_contour_values' = AbstractState_criticality_contour_values, 'tangent_plane_distance' = AbstractState_tangent_plane_distance, 'T_reducing' = AbstractState_T_reducing, 'rhomolar_reducing' = AbstractState_rhomolar_reducing, 'rhomass_reducing' = AbstractState_rhomass_reducing, 'p_triple' = AbstractState_p_triple, 'name' = AbstractState_name, 'dipole_moment' = AbstractState_dipole_moment, 'keyed_output' = AbstractState_keyed_output, 'trivial_keyed_output' = AbstractState_trivial_keyed_output, 'saturated_liquid_keyed_output' = AbstractState_saturated_liquid_keyed_output, 'saturated_vapor_keyed_output' = AbstractState_saturated_vapor_keyed_output, 'T' = AbstractState_T, 'rhomolar' = AbstractState_rhomolar, 'rhomass' = AbstractState_rhomass, 'p' = AbstractState_p, 'Q' = AbstractState_Q, 'tau' = AbstractState_tau, 'delta' = AbstractState_delta, 'molar_mass' = AbstractState_molar_mass, 'acentric_factor' = AbstractState_acentric_factor, 'gas_constant' = AbstractState_gas_constant, 'Bvirial' = AbstractState_Bvirial, 'dBvirial_dT' = AbstractState_dBvirial_dT, 'Cvirial' = AbstractState_Cvirial, 'dCvirial_dT' = AbstractState_dCvirial_dT, 'compressibility_factor' = AbstractState_compressibility_factor, 'hmolar' = AbstractState_hmolar, 'hmass' = AbstractState_hmass, 'hmolar_excess' = AbstractState_hmolar_excess, 'hmass_excess' = AbstractState_hmass_excess, 'smolar' = AbstractState_smolar, 'smass' = AbstractState_smass, 'smolar_excess' = AbstractState_smolar_excess, 'smass_excess' = AbstractState_smass_excess, 'umolar' = AbstractState_umolar, 'umass' = AbstractState_umass, 'umolar_excess' = AbstractState_umolar_excess, 'umass_excess' = AbstractState_umass_excess, 'cpmolar' = AbstractState_cpmolar, 'cpmass' = AbstractState_cpmass, 'cp0molar' = AbstractState_cp0molar, 'cp0mass' = AbstractState_cp0mass, 'cvmolar' = AbstractState_cvmolar, 'cvmass' = AbstractState_cvmass, 'gibbsmolar' = AbstractState_gibbsmolar, 'gibbsmass' = AbstractState_gibbsmass, 'gibbsmolar_excess' = AbstractState_gibbsmolar_excess, 'gibbsmass_excess' = AbstractState_gibbsmass_excess, 'helmholtzmolar' = AbstractState_helmholtzmolar, 'helmholtzmass' = AbstractState_helmholtzmass, 'helmholtzmolar_excess' = AbstractState_helmholtzmolar_excess, 'helmholtzmass_excess' = AbstractState_helmholtzmass_excess, 'volumemolar_excess' = AbstractState_volumemolar_excess, 'volumemass_excess' = AbstractState_volumemass_excess, 'speed_sound' = AbstractState_speed_sound, 'isothermal_compressibility' = AbstractState_isothermal_compressibility, 'isobaric_expansion_coefficient' = AbstractState_isobaric_expansion_coefficient, 'fugacity_coefficient' = AbstractState_fugacity_coefficient, 'fugacity' = AbstractState_fugacity, 'chemical_potential' = AbstractState_chemical_potential, 'fundamental_derivative_of_gas_dynamics' = AbstractState_fundamental_derivative_of_gas_dynamics, 'PIP' = AbstractState_PIP, 'true_critical_point' = AbstractState_true_critical_point, 'ideal_curve' = AbstractState_ideal_curve, 'first_partial_deriv' = AbstractState_first_partial_deriv, 'second_partial_deriv' = AbstractState_second_partial_deriv, 'first_saturation_deriv' = AbstractState_first_saturation_deriv, 'second_saturation_deriv' = AbstractState_second_saturation_deriv, 'first_two_phase_deriv' = AbstractState_first_two_phase_deriv, 'second_two_phase_deriv' = AbstractState_second_two_phase_deriv, 'first_two_phase_deriv_splined' = AbstractState_first_two_phase_deriv_splined, 'build_phase_envelope' = AbstractState_build_phase_envelope, 'get_phase_envelope_data' = AbstractState_get_phase_envelope_data, 'has_melting_line' = AbstractState_has_melting_line, 'melting_line' = AbstractState_melting_line, 'saturation_ancillary' = AbstractState_saturation_ancillary, 'viscosity' = AbstractState_viscosity, 'viscosity_contributions' = AbstractState_viscosity_contributions, 'conductivity' = AbstractState_conductivity, 'conductivity_contributions' = AbstractState_conductivity_contributions, 'surface_tension' = AbstractState_surface_tension, 'Prandtl' = AbstractState_Prandtl, 'conformal_state' = AbstractState_conformal_state, 'change_EOS' = AbstractState_change_EOS, 'alpha0' = AbstractState_alpha0, 'dalpha0_dDelta' = AbstractState_dalpha0_dDelta, 'dalpha0_dTau' = AbstractState_dalpha0_dTau, 'd2alpha0_dDelta2' = AbstractState_d2alpha0_dDelta2, 'd2alpha0_dDelta_dTau' = AbstractState_d2alpha0_dDelta_dTau, 'd2alpha0_dTau2' = AbstractState_d2alpha0_dTau2, 'd3alpha0_dTau3' = AbstractState_d3alpha0_dTau3, 'd3alpha0_dDelta_dTau2' = AbstractState_d3alpha0_dDelta_dTau2, 'd3alpha0_dDelta2_dTau' = AbstractState_d3alpha0_dDelta2_dTau, 'd3alpha0_dDelta3' = AbstractState_d3alpha0_dDelta3, 'alphar' = AbstractState_alphar, 'dalphar_dDelta' = AbstractState_dalphar_dDelta, 'dalphar_dTau' = AbstractState_dalphar_dTau, 'd2alphar_dDelta2' = AbstractState_d2alphar_dDelta2, 'd2alphar_dDelta_dTau' = AbstractState_d2alphar_dDelta_dTau, 'd2alphar_dTau2' = AbstractState_d2alphar_dTau2, 'd3alphar_dDelta3' = AbstractState_d3alphar_dDelta3, 'd3alphar_dDelta2_dTau' = AbstractState_d3alphar_dDelta2_dTau, 'd3alphar_dDelta_dTau2' = AbstractState_d3alphar_dDelta_dTau2, 'd3alphar_dTau3' = AbstractState_d3alphar_dTau3, 'd4alphar_dDelta4' = AbstractState_d4alphar_dDelta4, 'd4alphar_dDelta3_dTau' = AbstractState_d4alphar_dDelta3_dTau, 'd4alphar_dDelta2_dTau2' = AbstractState_d4alphar_dDelta2_dTau2, 'd4alphar_dDelta_dTau3' = AbstractState_d4alphar_dDelta_dTau3, 'd4alphar_dTau4' = AbstractState_d4alphar_dTau4);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for CoolProp::AbstractState
setMethod('delete', '_p_CoolProp__AbstractState', function(obj) {delete_CoolProp__AbstractState(obj)})
# Start of Props1SI

`Props1SI` = function(FluidName, Output, .copy = FALSE)
{
  FluidName = as(FluidName, "character"); 
  Output = as(Output, "character"); 
  ;.Call('R_swig_Props1SI', FluidName, Output, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`Props1SI`, 'returnType') = 'numeric'
attr(`Props1SI`, "inputTypes") = c('character', 'character')
class(`Props1SI`) = c("SWIGFunction", class('Props1SI'))

# Start of PropsSI

`PropsSI` = function(Output, Name1, Prop1, Name2, Prop2, FluidName, .copy = FALSE)
{
  Output = as(Output, "character"); 
  Name1 = as(Name1, "character"); 
  
  Name2 = as(Name2, "character"); 
  
  FluidName = as(FluidName, "character"); 
  ;.Call('R_swig_PropsSI', Output, Name1, Prop1, Name2, Prop2, FluidName, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`PropsSI`, 'returnType') = 'numeric'
attr(`PropsSI`, "inputTypes") = c('character', 'character', 'numeric', 'character', 'numeric', 'character')
class(`PropsSI`) = c("SWIGFunction", class('PropsSI'))

# Start of PropsSImulti

`PropsSImulti` = function(Outputs, Name1, Prop1, Name2, Prop2, backend, fluids, fractions, .copy = FALSE)
{
  if (inherits(Outputs, "ExternalReference")) Outputs = slot(Outputs,"ref") 
  Name1 = as(Name1, "character"); 
  
  Name2 = as(Name2, "character"); 
  
  backend = as(backend, "character"); 
  if (inherits(fluids, "ExternalReference")) fluids = slot(fluids,"ref") 
  
  ;.Call('R_swig_PropsSImulti', Outputs, Name1, Prop1, Name2, Prop2, backend, fluids, fractions, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`PropsSImulti`, 'returnType') = 'list'
attr(`PropsSImulti`, "inputTypes") = c('_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', 'character', '_p_std__vectorT_double_std__allocatorT_double_t_t', 'character', '_p_std__vectorT_double_std__allocatorT_double_t_t', 'character', '_p_std__vectorT_std__string_std__allocatorT_std__string_t_t', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`PropsSImulti`) = c("SWIGFunction", class('PropsSImulti'))

# Start of get_debug_level

`get_debug_level` = function(.copy = FALSE)
{
  ;.Call('R_swig_get_debug_level', as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`get_debug_level`, 'returnType') = 'integer'
class(`get_debug_level`) = c("SWIGFunction", class('get_debug_level'))

# Start of set_debug_level

`set_debug_level` = function(level)
{
  level = as.integer(level);
  
  if(length(level) > 1) {
    warning("using only the first element of level");
  };
  
  ;.Call('R_swig_set_debug_level', level, PACKAGE='CoolProp');
  
}

attr(`set_debug_level`, 'returnType') = 'void'
attr(`set_debug_level`, "inputTypes") = c('integer')
class(`set_debug_level`) = c("SWIGFunction", class('set_debug_level'))

# Start of set_error_string

`set_error_string` = function(error)
{
  error = as(error, "character"); 
  ;.Call('R_swig_set_error_string', error, PACKAGE='CoolProp');
  
}

attr(`set_error_string`, 'returnType') = 'void'
attr(`set_error_string`, "inputTypes") = c('character')
class(`set_error_string`) = c("SWIGFunction", class('set_error_string'))

# Start of set_warning_string

`set_warning_string` = function(warning)
{
  warning = as(warning, "character"); 
  ;.Call('R_swig_set_warning_string', warning, PACKAGE='CoolProp');
  
}

attr(`set_warning_string`, 'returnType') = 'void'
attr(`set_warning_string`, "inputTypes") = c('character')
class(`set_warning_string`) = c("SWIGFunction", class('set_warning_string'))

# Start of saturation_ancillary

`saturation_ancillary` = function(fluid_name, output, Q, input, value, .copy = FALSE)
{
  fluid_name = as(fluid_name, "character"); 
  output = as(output, "character"); 
  Q = as.integer(Q);
  
  if(length(Q) > 1) {
    warning("using only the first element of Q");
  };
  
  input = as(input, "character"); 
  
  ;.Call('R_swig_saturation_ancillary', fluid_name, output, Q, input, value, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`saturation_ancillary`, 'returnType') = 'numeric'
attr(`saturation_ancillary`, "inputTypes") = c('character', 'character', 'integer', 'character', 'numeric')
class(`saturation_ancillary`) = c("SWIGFunction", class('saturation_ancillary'))

# Start of get_global_param_string

`get_global_param_string` = function(ParamName, .copy = FALSE)
{
  ParamName = as(ParamName, "character"); 
  ;.Call('R_swig_get_global_param_string', ParamName, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`get_global_param_string`, 'returnType') = 'character'
attr(`get_global_param_string`, "inputTypes") = c('character')
class(`get_global_param_string`) = c("SWIGFunction", class('get_global_param_string'))

# Start of get_fluid_param_string

`get_fluid_param_string` = function(FluidName, ParamName, .copy = FALSE)
{
  FluidName = as(FluidName, "character"); 
  ParamName = as(ParamName, "character"); 
  ;.Call('R_swig_get_fluid_param_string', FluidName, ParamName, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`get_fluid_param_string`, 'returnType') = 'character'
attr(`get_fluid_param_string`, "inputTypes") = c('character', 'character')
class(`get_fluid_param_string`) = c("SWIGFunction", class('get_fluid_param_string'))

# Start of is_valid_fluid_string

`is_valid_fluid_string` = function(fluidstring, .copy = FALSE)
{
  fluidstring = as(fluidstring, "character"); 
  ;.Call('R_swig_is_valid_fluid_string', fluidstring, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`is_valid_fluid_string`, 'returnType') = 'logical'
attr(`is_valid_fluid_string`, "inputTypes") = c('character')
class(`is_valid_fluid_string`) = c("SWIGFunction", class('is_valid_fluid_string'))

# Start of add_fluids_as_JSON

`add_fluids_as_JSON` = function(backend, fluidstring, .copy = FALSE)
{
  backend = as(backend, "character"); 
  fluidstring = as(fluidstring, "character"); 
  ;.Call('R_swig_add_fluids_as_JSON', backend, fluidstring, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`add_fluids_as_JSON`, 'returnType') = 'logical'
attr(`add_fluids_as_JSON`, "inputTypes") = c('character', 'character')
class(`add_fluids_as_JSON`) = c("SWIGFunction", class('add_fluids_as_JSON'))

# Start of set_reference_stateS

`set_reference_stateS` = function(FluidName, reference_state)
{
  FluidName = as(FluidName, "character"); 
  reference_state = as(reference_state, "character"); 
  ;.Call('R_swig_set_reference_stateS', FluidName, reference_state, PACKAGE='CoolProp');
  
}

attr(`set_reference_stateS`, 'returnType') = 'void'
attr(`set_reference_stateS`, "inputTypes") = c('character', 'character')
class(`set_reference_stateS`) = c("SWIGFunction", class('set_reference_stateS'))

# Start of set_reference_stateD

`set_reference_stateD` = function(FluidName, T, rhomolar, hmolar0, smolar0)
{
  FluidName = as(FluidName, "character"); 
  
  
  
  
  ;.Call('R_swig_set_reference_stateD', FluidName, T, rhomolar, hmolar0, smolar0, PACKAGE='CoolProp');
  
}

attr(`set_reference_stateD`, 'returnType') = 'void'
attr(`set_reference_stateD`, "inputTypes") = c('character', 'numeric', 'numeric', 'numeric', 'numeric')
class(`set_reference_stateD`) = c("SWIGFunction", class('set_reference_stateD'))

# Start of PhaseSI

`PhaseSI` = function(Name1, Prop1, Name2, Prop2, FluidName, .copy = FALSE)
{
  Name1 = as(Name1, "character"); 
  
  Name2 = as(Name2, "character"); 
  
  FluidName = as(FluidName, "character"); 
  ;.Call('R_swig_PhaseSI', Name1, Prop1, Name2, Prop2, FluidName, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`PhaseSI`, 'returnType') = 'character'
attr(`PhaseSI`, "inputTypes") = c('character', 'numeric', 'character', 'numeric', 'character')
class(`PhaseSI`) = c("SWIGFunction", class('PhaseSI'))

# Start of extract_backend

`extract_backend` = function(fluid_string, backend, fluid)
{
  fluid_string = as(fluid_string, "character"); 
  backend = as(backend, "character"); 
  fluid = as(fluid, "character"); 
  ;.Call('R_swig_extract_backend', fluid_string, backend, fluid, PACKAGE='CoolProp');
  
}

attr(`extract_backend`, 'returnType') = 'void'
attr(`extract_backend`, "inputTypes") = c('character', 'character', 'character')
class(`extract_backend`) = c("SWIGFunction", class('extract_backend'))

# Start of extract_fractions

`extract_fractions` = function(fluid_string, fractions, .copy = FALSE)
{
  fluid_string = as(fluid_string, "character"); 
  if (inherits(fractions, "ExternalReference")) fractions = slot(fractions,"ref") 
  ;.Call('R_swig_extract_fractions', fluid_string, fractions, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`extract_fractions`, 'returnType') = 'character'
attr(`extract_fractions`, "inputTypes") = c('character', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`extract_fractions`) = c("SWIGFunction", class('extract_fractions'))

# Start of PhaseEnvelopeData_TypeI_set

`PhaseEnvelopeData_TypeI_set` = function(self, s_TypeI)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_TypeI = as.logical(s_TypeI);
  ;.Call('R_swig_PhaseEnvelopeData_TypeI_set', self, s_TypeI, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_TypeI_set`, 'returnType') = 'void'
attr(`PhaseEnvelopeData_TypeI_set`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData', 'logical')
class(`PhaseEnvelopeData_TypeI_set`) = c("SWIGFunction", class('PhaseEnvelopeData_TypeI_set'))

# Start of PhaseEnvelopeData_TypeI_get

`PhaseEnvelopeData_TypeI_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_TypeI_get', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_TypeI_get`, 'returnType') = 'logical'
attr(`PhaseEnvelopeData_TypeI_get`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData')
class(`PhaseEnvelopeData_TypeI_get`) = c("SWIGFunction", class('PhaseEnvelopeData_TypeI_get'))

# Start of PhaseEnvelopeData_built_set

`PhaseEnvelopeData_built_set` = function(self, s_built)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_built = as.logical(s_built);
  ;.Call('R_swig_PhaseEnvelopeData_built_set', self, s_built, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_built_set`, 'returnType') = 'void'
attr(`PhaseEnvelopeData_built_set`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData', 'logical')
class(`PhaseEnvelopeData_built_set`) = c("SWIGFunction", class('PhaseEnvelopeData_built_set'))

# Start of PhaseEnvelopeData_built_get

`PhaseEnvelopeData_built_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_built_get', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_built_get`, 'returnType') = 'logical'
attr(`PhaseEnvelopeData_built_get`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData')
class(`PhaseEnvelopeData_built_get`) = c("SWIGFunction", class('PhaseEnvelopeData_built_get'))

# Start of PhaseEnvelopeData_iTsat_max_set

`PhaseEnvelopeData_iTsat_max_set` = function(self, s_iTsat_max)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_iTsat_max = as.integer(s_iTsat_max);
  
  if(length(s_iTsat_max) > 1) {
    warning("using only the first element of s_iTsat_max");
  };
  
  ;.Call('R_swig_PhaseEnvelopeData_iTsat_max_set', self, s_iTsat_max, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_iTsat_max_set`, 'returnType') = 'void'
attr(`PhaseEnvelopeData_iTsat_max_set`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData', 'integer')
class(`PhaseEnvelopeData_iTsat_max_set`) = c("SWIGFunction", class('PhaseEnvelopeData_iTsat_max_set'))

# Start of PhaseEnvelopeData_iTsat_max_get

`PhaseEnvelopeData_iTsat_max_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_iTsat_max_get', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_iTsat_max_get`, 'returnType') = 'integer'
attr(`PhaseEnvelopeData_iTsat_max_get`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData')
class(`PhaseEnvelopeData_iTsat_max_get`) = c("SWIGFunction", class('PhaseEnvelopeData_iTsat_max_get'))

# Start of PhaseEnvelopeData_ipsat_max_set

`PhaseEnvelopeData_ipsat_max_set` = function(self, s_ipsat_max)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_ipsat_max = as.integer(s_ipsat_max);
  
  if(length(s_ipsat_max) > 1) {
    warning("using only the first element of s_ipsat_max");
  };
  
  ;.Call('R_swig_PhaseEnvelopeData_ipsat_max_set', self, s_ipsat_max, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_ipsat_max_set`, 'returnType') = 'void'
attr(`PhaseEnvelopeData_ipsat_max_set`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData', 'integer')
class(`PhaseEnvelopeData_ipsat_max_set`) = c("SWIGFunction", class('PhaseEnvelopeData_ipsat_max_set'))

# Start of PhaseEnvelopeData_ipsat_max_get

`PhaseEnvelopeData_ipsat_max_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_ipsat_max_get', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_ipsat_max_get`, 'returnType') = 'integer'
attr(`PhaseEnvelopeData_ipsat_max_get`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData')
class(`PhaseEnvelopeData_ipsat_max_get`) = c("SWIGFunction", class('PhaseEnvelopeData_ipsat_max_get'))

# Start of PhaseEnvelopeData_icrit_set

`PhaseEnvelopeData_icrit_set` = function(self, s_icrit)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  s_icrit = as.integer(s_icrit);
  
  if(length(s_icrit) > 1) {
    warning("using only the first element of s_icrit");
  };
  
  ;.Call('R_swig_PhaseEnvelopeData_icrit_set', self, s_icrit, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_icrit_set`, 'returnType') = 'void'
attr(`PhaseEnvelopeData_icrit_set`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData', 'integer')
class(`PhaseEnvelopeData_icrit_set`) = c("SWIGFunction", class('PhaseEnvelopeData_icrit_set'))

# Start of PhaseEnvelopeData_icrit_get

`PhaseEnvelopeData_icrit_get` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_icrit_get', self, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_icrit_get`, 'returnType') = 'integer'
attr(`PhaseEnvelopeData_icrit_get`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData')
class(`PhaseEnvelopeData_icrit_get`) = c("SWIGFunction", class('PhaseEnvelopeData_icrit_get'))

# Start of PhaseEnvelopeData_T_set

`PhaseEnvelopeData_T_set` = function(self, s_T)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_T, "ExternalReference")) s_T = slot(s_T,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_T_set', self, s_T, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_T_set`, 'returnType') = 'void'
attr(`PhaseEnvelopeData_T_set`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`PhaseEnvelopeData_T_set`) = c("SWIGFunction", class('PhaseEnvelopeData_T_set'))

# Start of PhaseEnvelopeData_T_get

`PhaseEnvelopeData_T_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_T_get', self, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_T_get`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`PhaseEnvelopeData_T_get`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData')
class(`PhaseEnvelopeData_T_get`) = c("SWIGFunction", class('PhaseEnvelopeData_T_get'))

# Start of PhaseEnvelopeData_p_set

`PhaseEnvelopeData_p_set` = function(self, s_p)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_p, "ExternalReference")) s_p = slot(s_p,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_p_set', self, s_p, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_p_set`, 'returnType') = 'void'
attr(`PhaseEnvelopeData_p_set`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`PhaseEnvelopeData_p_set`) = c("SWIGFunction", class('PhaseEnvelopeData_p_set'))

# Start of PhaseEnvelopeData_p_get

`PhaseEnvelopeData_p_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_p_get', self, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_p_get`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`PhaseEnvelopeData_p_get`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData')
class(`PhaseEnvelopeData_p_get`) = c("SWIGFunction", class('PhaseEnvelopeData_p_get'))

# Start of PhaseEnvelopeData_lnT_set

`PhaseEnvelopeData_lnT_set` = function(self, s_lnT)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_lnT, "ExternalReference")) s_lnT = slot(s_lnT,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_lnT_set', self, s_lnT, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_lnT_set`, 'returnType') = 'void'
attr(`PhaseEnvelopeData_lnT_set`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`PhaseEnvelopeData_lnT_set`) = c("SWIGFunction", class('PhaseEnvelopeData_lnT_set'))

# Start of PhaseEnvelopeData_lnT_get

`PhaseEnvelopeData_lnT_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_lnT_get', self, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_lnT_get`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`PhaseEnvelopeData_lnT_get`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData')
class(`PhaseEnvelopeData_lnT_get`) = c("SWIGFunction", class('PhaseEnvelopeData_lnT_get'))

# Start of PhaseEnvelopeData_lnp_set

`PhaseEnvelopeData_lnp_set` = function(self, s_lnp)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_lnp, "ExternalReference")) s_lnp = slot(s_lnp,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_lnp_set', self, s_lnp, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_lnp_set`, 'returnType') = 'void'
attr(`PhaseEnvelopeData_lnp_set`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`PhaseEnvelopeData_lnp_set`) = c("SWIGFunction", class('PhaseEnvelopeData_lnp_set'))

# Start of PhaseEnvelopeData_lnp_get

`PhaseEnvelopeData_lnp_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_lnp_get', self, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_lnp_get`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`PhaseEnvelopeData_lnp_get`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData')
class(`PhaseEnvelopeData_lnp_get`) = c("SWIGFunction", class('PhaseEnvelopeData_lnp_get'))

# Start of PhaseEnvelopeData_rhomolar_liq_set

`PhaseEnvelopeData_rhomolar_liq_set` = function(self, s_rhomolar_liq)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_rhomolar_liq, "ExternalReference")) s_rhomolar_liq = slot(s_rhomolar_liq,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_rhomolar_liq_set', self, s_rhomolar_liq, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_rhomolar_liq_set`, 'returnType') = 'void'
attr(`PhaseEnvelopeData_rhomolar_liq_set`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`PhaseEnvelopeData_rhomolar_liq_set`) = c("SWIGFunction", class('PhaseEnvelopeData_rhomolar_liq_set'))

# Start of PhaseEnvelopeData_rhomolar_liq_get

`PhaseEnvelopeData_rhomolar_liq_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_rhomolar_liq_get', self, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_rhomolar_liq_get`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`PhaseEnvelopeData_rhomolar_liq_get`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData')
class(`PhaseEnvelopeData_rhomolar_liq_get`) = c("SWIGFunction", class('PhaseEnvelopeData_rhomolar_liq_get'))

# Start of PhaseEnvelopeData_rhomolar_vap_set

`PhaseEnvelopeData_rhomolar_vap_set` = function(self, s_rhomolar_vap)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_rhomolar_vap, "ExternalReference")) s_rhomolar_vap = slot(s_rhomolar_vap,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_rhomolar_vap_set', self, s_rhomolar_vap, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_rhomolar_vap_set`, 'returnType') = 'void'
attr(`PhaseEnvelopeData_rhomolar_vap_set`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`PhaseEnvelopeData_rhomolar_vap_set`) = c("SWIGFunction", class('PhaseEnvelopeData_rhomolar_vap_set'))

# Start of PhaseEnvelopeData_rhomolar_vap_get

`PhaseEnvelopeData_rhomolar_vap_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_rhomolar_vap_get', self, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_rhomolar_vap_get`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`PhaseEnvelopeData_rhomolar_vap_get`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData')
class(`PhaseEnvelopeData_rhomolar_vap_get`) = c("SWIGFunction", class('PhaseEnvelopeData_rhomolar_vap_get'))

# Start of PhaseEnvelopeData_lnrhomolar_liq_set

`PhaseEnvelopeData_lnrhomolar_liq_set` = function(self, s_lnrhomolar_liq)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_lnrhomolar_liq, "ExternalReference")) s_lnrhomolar_liq = slot(s_lnrhomolar_liq,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_lnrhomolar_liq_set', self, s_lnrhomolar_liq, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_lnrhomolar_liq_set`, 'returnType') = 'void'
attr(`PhaseEnvelopeData_lnrhomolar_liq_set`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`PhaseEnvelopeData_lnrhomolar_liq_set`) = c("SWIGFunction", class('PhaseEnvelopeData_lnrhomolar_liq_set'))

# Start of PhaseEnvelopeData_lnrhomolar_liq_get

`PhaseEnvelopeData_lnrhomolar_liq_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_lnrhomolar_liq_get', self, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_lnrhomolar_liq_get`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`PhaseEnvelopeData_lnrhomolar_liq_get`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData')
class(`PhaseEnvelopeData_lnrhomolar_liq_get`) = c("SWIGFunction", class('PhaseEnvelopeData_lnrhomolar_liq_get'))

# Start of PhaseEnvelopeData_lnrhomolar_vap_set

`PhaseEnvelopeData_lnrhomolar_vap_set` = function(self, s_lnrhomolar_vap)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_lnrhomolar_vap, "ExternalReference")) s_lnrhomolar_vap = slot(s_lnrhomolar_vap,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_lnrhomolar_vap_set', self, s_lnrhomolar_vap, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_lnrhomolar_vap_set`, 'returnType') = 'void'
attr(`PhaseEnvelopeData_lnrhomolar_vap_set`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`PhaseEnvelopeData_lnrhomolar_vap_set`) = c("SWIGFunction", class('PhaseEnvelopeData_lnrhomolar_vap_set'))

# Start of PhaseEnvelopeData_lnrhomolar_vap_get

`PhaseEnvelopeData_lnrhomolar_vap_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_lnrhomolar_vap_get', self, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_lnrhomolar_vap_get`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`PhaseEnvelopeData_lnrhomolar_vap_get`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData')
class(`PhaseEnvelopeData_lnrhomolar_vap_get`) = c("SWIGFunction", class('PhaseEnvelopeData_lnrhomolar_vap_get'))

# Start of PhaseEnvelopeData_hmolar_liq_set

`PhaseEnvelopeData_hmolar_liq_set` = function(self, s_hmolar_liq)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_hmolar_liq, "ExternalReference")) s_hmolar_liq = slot(s_hmolar_liq,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_hmolar_liq_set', self, s_hmolar_liq, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_hmolar_liq_set`, 'returnType') = 'void'
attr(`PhaseEnvelopeData_hmolar_liq_set`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`PhaseEnvelopeData_hmolar_liq_set`) = c("SWIGFunction", class('PhaseEnvelopeData_hmolar_liq_set'))

# Start of PhaseEnvelopeData_hmolar_liq_get

`PhaseEnvelopeData_hmolar_liq_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_hmolar_liq_get', self, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_hmolar_liq_get`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`PhaseEnvelopeData_hmolar_liq_get`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData')
class(`PhaseEnvelopeData_hmolar_liq_get`) = c("SWIGFunction", class('PhaseEnvelopeData_hmolar_liq_get'))

# Start of PhaseEnvelopeData_hmolar_vap_set

`PhaseEnvelopeData_hmolar_vap_set` = function(self, s_hmolar_vap)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_hmolar_vap, "ExternalReference")) s_hmolar_vap = slot(s_hmolar_vap,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_hmolar_vap_set', self, s_hmolar_vap, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_hmolar_vap_set`, 'returnType') = 'void'
attr(`PhaseEnvelopeData_hmolar_vap_set`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`PhaseEnvelopeData_hmolar_vap_set`) = c("SWIGFunction", class('PhaseEnvelopeData_hmolar_vap_set'))

# Start of PhaseEnvelopeData_hmolar_vap_get

`PhaseEnvelopeData_hmolar_vap_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_hmolar_vap_get', self, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_hmolar_vap_get`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`PhaseEnvelopeData_hmolar_vap_get`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData')
class(`PhaseEnvelopeData_hmolar_vap_get`) = c("SWIGFunction", class('PhaseEnvelopeData_hmolar_vap_get'))

# Start of PhaseEnvelopeData_smolar_liq_set

`PhaseEnvelopeData_smolar_liq_set` = function(self, s_smolar_liq)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_smolar_liq, "ExternalReference")) s_smolar_liq = slot(s_smolar_liq,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_smolar_liq_set', self, s_smolar_liq, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_smolar_liq_set`, 'returnType') = 'void'
attr(`PhaseEnvelopeData_smolar_liq_set`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`PhaseEnvelopeData_smolar_liq_set`) = c("SWIGFunction", class('PhaseEnvelopeData_smolar_liq_set'))

# Start of PhaseEnvelopeData_smolar_liq_get

`PhaseEnvelopeData_smolar_liq_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_smolar_liq_get', self, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_smolar_liq_get`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`PhaseEnvelopeData_smolar_liq_get`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData')
class(`PhaseEnvelopeData_smolar_liq_get`) = c("SWIGFunction", class('PhaseEnvelopeData_smolar_liq_get'))

# Start of PhaseEnvelopeData_smolar_vap_set

`PhaseEnvelopeData_smolar_vap_set` = function(self, s_smolar_vap)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_smolar_vap, "ExternalReference")) s_smolar_vap = slot(s_smolar_vap,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_smolar_vap_set', self, s_smolar_vap, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_smolar_vap_set`, 'returnType') = 'void'
attr(`PhaseEnvelopeData_smolar_vap_set`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`PhaseEnvelopeData_smolar_vap_set`) = c("SWIGFunction", class('PhaseEnvelopeData_smolar_vap_set'))

# Start of PhaseEnvelopeData_smolar_vap_get

`PhaseEnvelopeData_smolar_vap_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_smolar_vap_get', self, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_smolar_vap_get`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`PhaseEnvelopeData_smolar_vap_get`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData')
class(`PhaseEnvelopeData_smolar_vap_get`) = c("SWIGFunction", class('PhaseEnvelopeData_smolar_vap_get'))

# Start of PhaseEnvelopeData_Q_set

`PhaseEnvelopeData_Q_set` = function(self, s_Q)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_Q, "ExternalReference")) s_Q = slot(s_Q,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_Q_set', self, s_Q, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_Q_set`, 'returnType') = 'void'
attr(`PhaseEnvelopeData_Q_set`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`PhaseEnvelopeData_Q_set`) = c("SWIGFunction", class('PhaseEnvelopeData_Q_set'))

# Start of PhaseEnvelopeData_Q_get

`PhaseEnvelopeData_Q_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_Q_get', self, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_Q_get`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`PhaseEnvelopeData_Q_get`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData')
class(`PhaseEnvelopeData_Q_get`) = c("SWIGFunction", class('PhaseEnvelopeData_Q_get'))

# Start of PhaseEnvelopeData_cpmolar_liq_set

`PhaseEnvelopeData_cpmolar_liq_set` = function(self, s_cpmolar_liq)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_cpmolar_liq, "ExternalReference")) s_cpmolar_liq = slot(s_cpmolar_liq,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_cpmolar_liq_set', self, s_cpmolar_liq, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_cpmolar_liq_set`, 'returnType') = 'void'
attr(`PhaseEnvelopeData_cpmolar_liq_set`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`PhaseEnvelopeData_cpmolar_liq_set`) = c("SWIGFunction", class('PhaseEnvelopeData_cpmolar_liq_set'))

# Start of PhaseEnvelopeData_cpmolar_liq_get

`PhaseEnvelopeData_cpmolar_liq_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_cpmolar_liq_get', self, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_cpmolar_liq_get`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`PhaseEnvelopeData_cpmolar_liq_get`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData')
class(`PhaseEnvelopeData_cpmolar_liq_get`) = c("SWIGFunction", class('PhaseEnvelopeData_cpmolar_liq_get'))

# Start of PhaseEnvelopeData_cpmolar_vap_set

`PhaseEnvelopeData_cpmolar_vap_set` = function(self, s_cpmolar_vap)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_cpmolar_vap, "ExternalReference")) s_cpmolar_vap = slot(s_cpmolar_vap,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_cpmolar_vap_set', self, s_cpmolar_vap, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_cpmolar_vap_set`, 'returnType') = 'void'
attr(`PhaseEnvelopeData_cpmolar_vap_set`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`PhaseEnvelopeData_cpmolar_vap_set`) = c("SWIGFunction", class('PhaseEnvelopeData_cpmolar_vap_set'))

# Start of PhaseEnvelopeData_cpmolar_vap_get

`PhaseEnvelopeData_cpmolar_vap_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_cpmolar_vap_get', self, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_cpmolar_vap_get`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`PhaseEnvelopeData_cpmolar_vap_get`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData')
class(`PhaseEnvelopeData_cpmolar_vap_get`) = c("SWIGFunction", class('PhaseEnvelopeData_cpmolar_vap_get'))

# Start of PhaseEnvelopeData_cvmolar_liq_set

`PhaseEnvelopeData_cvmolar_liq_set` = function(self, s_cvmolar_liq)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_cvmolar_liq, "ExternalReference")) s_cvmolar_liq = slot(s_cvmolar_liq,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_cvmolar_liq_set', self, s_cvmolar_liq, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_cvmolar_liq_set`, 'returnType') = 'void'
attr(`PhaseEnvelopeData_cvmolar_liq_set`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`PhaseEnvelopeData_cvmolar_liq_set`) = c("SWIGFunction", class('PhaseEnvelopeData_cvmolar_liq_set'))

# Start of PhaseEnvelopeData_cvmolar_liq_get

`PhaseEnvelopeData_cvmolar_liq_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_cvmolar_liq_get', self, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_cvmolar_liq_get`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`PhaseEnvelopeData_cvmolar_liq_get`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData')
class(`PhaseEnvelopeData_cvmolar_liq_get`) = c("SWIGFunction", class('PhaseEnvelopeData_cvmolar_liq_get'))

# Start of PhaseEnvelopeData_cvmolar_vap_set

`PhaseEnvelopeData_cvmolar_vap_set` = function(self, s_cvmolar_vap)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_cvmolar_vap, "ExternalReference")) s_cvmolar_vap = slot(s_cvmolar_vap,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_cvmolar_vap_set', self, s_cvmolar_vap, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_cvmolar_vap_set`, 'returnType') = 'void'
attr(`PhaseEnvelopeData_cvmolar_vap_set`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`PhaseEnvelopeData_cvmolar_vap_set`) = c("SWIGFunction", class('PhaseEnvelopeData_cvmolar_vap_set'))

# Start of PhaseEnvelopeData_cvmolar_vap_get

`PhaseEnvelopeData_cvmolar_vap_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_cvmolar_vap_get', self, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_cvmolar_vap_get`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`PhaseEnvelopeData_cvmolar_vap_get`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData')
class(`PhaseEnvelopeData_cvmolar_vap_get`) = c("SWIGFunction", class('PhaseEnvelopeData_cvmolar_vap_get'))

# Start of PhaseEnvelopeData_viscosity_liq_set

`PhaseEnvelopeData_viscosity_liq_set` = function(self, s_viscosity_liq)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_viscosity_liq, "ExternalReference")) s_viscosity_liq = slot(s_viscosity_liq,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_viscosity_liq_set', self, s_viscosity_liq, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_viscosity_liq_set`, 'returnType') = 'void'
attr(`PhaseEnvelopeData_viscosity_liq_set`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`PhaseEnvelopeData_viscosity_liq_set`) = c("SWIGFunction", class('PhaseEnvelopeData_viscosity_liq_set'))

# Start of PhaseEnvelopeData_viscosity_liq_get

`PhaseEnvelopeData_viscosity_liq_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_viscosity_liq_get', self, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_viscosity_liq_get`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`PhaseEnvelopeData_viscosity_liq_get`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData')
class(`PhaseEnvelopeData_viscosity_liq_get`) = c("SWIGFunction", class('PhaseEnvelopeData_viscosity_liq_get'))

# Start of PhaseEnvelopeData_viscosity_vap_set

`PhaseEnvelopeData_viscosity_vap_set` = function(self, s_viscosity_vap)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_viscosity_vap, "ExternalReference")) s_viscosity_vap = slot(s_viscosity_vap,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_viscosity_vap_set', self, s_viscosity_vap, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_viscosity_vap_set`, 'returnType') = 'void'
attr(`PhaseEnvelopeData_viscosity_vap_set`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`PhaseEnvelopeData_viscosity_vap_set`) = c("SWIGFunction", class('PhaseEnvelopeData_viscosity_vap_set'))

# Start of PhaseEnvelopeData_viscosity_vap_get

`PhaseEnvelopeData_viscosity_vap_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_viscosity_vap_get', self, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_viscosity_vap_get`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`PhaseEnvelopeData_viscosity_vap_get`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData')
class(`PhaseEnvelopeData_viscosity_vap_get`) = c("SWIGFunction", class('PhaseEnvelopeData_viscosity_vap_get'))

# Start of PhaseEnvelopeData_conductivity_liq_set

`PhaseEnvelopeData_conductivity_liq_set` = function(self, s_conductivity_liq)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_conductivity_liq, "ExternalReference")) s_conductivity_liq = slot(s_conductivity_liq,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_conductivity_liq_set', self, s_conductivity_liq, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_conductivity_liq_set`, 'returnType') = 'void'
attr(`PhaseEnvelopeData_conductivity_liq_set`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`PhaseEnvelopeData_conductivity_liq_set`) = c("SWIGFunction", class('PhaseEnvelopeData_conductivity_liq_set'))

# Start of PhaseEnvelopeData_conductivity_liq_get

`PhaseEnvelopeData_conductivity_liq_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_conductivity_liq_get', self, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_conductivity_liq_get`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`PhaseEnvelopeData_conductivity_liq_get`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData')
class(`PhaseEnvelopeData_conductivity_liq_get`) = c("SWIGFunction", class('PhaseEnvelopeData_conductivity_liq_get'))

# Start of PhaseEnvelopeData_conductivity_vap_set

`PhaseEnvelopeData_conductivity_vap_set` = function(self, s_conductivity_vap)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_conductivity_vap, "ExternalReference")) s_conductivity_vap = slot(s_conductivity_vap,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_conductivity_vap_set', self, s_conductivity_vap, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_conductivity_vap_set`, 'returnType') = 'void'
attr(`PhaseEnvelopeData_conductivity_vap_set`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`PhaseEnvelopeData_conductivity_vap_set`) = c("SWIGFunction", class('PhaseEnvelopeData_conductivity_vap_set'))

# Start of PhaseEnvelopeData_conductivity_vap_get

`PhaseEnvelopeData_conductivity_vap_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_conductivity_vap_get', self, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_conductivity_vap_get`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`PhaseEnvelopeData_conductivity_vap_get`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData')
class(`PhaseEnvelopeData_conductivity_vap_get`) = c("SWIGFunction", class('PhaseEnvelopeData_conductivity_vap_get'))

# Start of PhaseEnvelopeData_speed_sound_vap_set

`PhaseEnvelopeData_speed_sound_vap_set` = function(self, s_speed_sound_vap)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_speed_sound_vap, "ExternalReference")) s_speed_sound_vap = slot(s_speed_sound_vap,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_speed_sound_vap_set', self, s_speed_sound_vap, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_speed_sound_vap_set`, 'returnType') = 'void'
attr(`PhaseEnvelopeData_speed_sound_vap_set`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData', '_p_std__vectorT_double_std__allocatorT_double_t_t')
class(`PhaseEnvelopeData_speed_sound_vap_set`) = c("SWIGFunction", class('PhaseEnvelopeData_speed_sound_vap_set'))

# Start of PhaseEnvelopeData_speed_sound_vap_get

`PhaseEnvelopeData_speed_sound_vap_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_speed_sound_vap_get', self, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_speed_sound_vap_get`, 'returnType') = '_p_std__vectorT_double_std__allocatorT_double_t_t'
attr(`PhaseEnvelopeData_speed_sound_vap_get`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData')
class(`PhaseEnvelopeData_speed_sound_vap_get`) = c("SWIGFunction", class('PhaseEnvelopeData_speed_sound_vap_get'))

# Start of PhaseEnvelopeData_K_set

`PhaseEnvelopeData_K_set` = function(self, s_K)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_K, "ExternalReference")) s_K = slot(s_K,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_K_set', self, s_K, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_K_set`, 'returnType') = 'void'
attr(`PhaseEnvelopeData_K_set`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData', '_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t')
class(`PhaseEnvelopeData_K_set`) = c("SWIGFunction", class('PhaseEnvelopeData_K_set'))

# Start of PhaseEnvelopeData_K_get

`PhaseEnvelopeData_K_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_K_get', self, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_K_get`, 'returnType') = '_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t'
attr(`PhaseEnvelopeData_K_get`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData')
class(`PhaseEnvelopeData_K_get`) = c("SWIGFunction", class('PhaseEnvelopeData_K_get'))

# Start of PhaseEnvelopeData_lnK_set

`PhaseEnvelopeData_lnK_set` = function(self, s_lnK)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_lnK, "ExternalReference")) s_lnK = slot(s_lnK,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_lnK_set', self, s_lnK, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_lnK_set`, 'returnType') = 'void'
attr(`PhaseEnvelopeData_lnK_set`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData', '_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t')
class(`PhaseEnvelopeData_lnK_set`) = c("SWIGFunction", class('PhaseEnvelopeData_lnK_set'))

# Start of PhaseEnvelopeData_lnK_get

`PhaseEnvelopeData_lnK_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_lnK_get', self, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_lnK_get`, 'returnType') = '_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t'
attr(`PhaseEnvelopeData_lnK_get`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData')
class(`PhaseEnvelopeData_lnK_get`) = c("SWIGFunction", class('PhaseEnvelopeData_lnK_get'))

# Start of PhaseEnvelopeData_x_set

`PhaseEnvelopeData_x_set` = function(self, s_x)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_x, "ExternalReference")) s_x = slot(s_x,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_x_set', self, s_x, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_x_set`, 'returnType') = 'void'
attr(`PhaseEnvelopeData_x_set`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData', '_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t')
class(`PhaseEnvelopeData_x_set`) = c("SWIGFunction", class('PhaseEnvelopeData_x_set'))

# Start of PhaseEnvelopeData_x_get

`PhaseEnvelopeData_x_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_x_get', self, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_x_get`, 'returnType') = '_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t'
attr(`PhaseEnvelopeData_x_get`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData')
class(`PhaseEnvelopeData_x_get`) = c("SWIGFunction", class('PhaseEnvelopeData_x_get'))

# Start of PhaseEnvelopeData_y_set

`PhaseEnvelopeData_y_set` = function(self, s_y)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(s_y, "ExternalReference")) s_y = slot(s_y,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_y_set', self, s_y, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_y_set`, 'returnType') = 'void'
attr(`PhaseEnvelopeData_y_set`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData', '_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t')
class(`PhaseEnvelopeData_y_set`) = c("SWIGFunction", class('PhaseEnvelopeData_y_set'))

# Start of PhaseEnvelopeData_y_get

`PhaseEnvelopeData_y_get` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_y_get', self, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_y_get`, 'returnType') = '_p_std__vectorT_std__vectorT_double_std__allocatorT_double_t_t_std__allocatorT_std__vectorT_double_std__allocatorT_double_t_t_t_t'
attr(`PhaseEnvelopeData_y_get`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData')
class(`PhaseEnvelopeData_y_get`) = c("SWIGFunction", class('PhaseEnvelopeData_y_get'))

# Start of new_PhaseEnvelopeData

`PhaseEnvelopeData` = function()
{
  ;ans = .Call('R_swig_new_PhaseEnvelopeData', PACKAGE='CoolProp');
  ans <- new("_p_CoolProp__PhaseEnvelopeData", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_PhaseEnvelopeData)
  ans
  
}

attr(`PhaseEnvelopeData`, 'returnType') = '_p_CoolProp__PhaseEnvelopeData'
class(`PhaseEnvelopeData`) = c("SWIGFunction", class('PhaseEnvelopeData'))

# Start of PhaseEnvelopeData_resize

`PhaseEnvelopeData_resize` = function(self, N)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  N = as.integer(N);
  
  if(length(N) > 1) {
    warning("using only the first element of N");
  };
  
  ;.Call('R_swig_PhaseEnvelopeData_resize', self, N, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_resize`, 'returnType') = 'void'
attr(`PhaseEnvelopeData_resize`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData', 'integer')
class(`PhaseEnvelopeData_resize`) = c("SWIGFunction", class('PhaseEnvelopeData_resize'))

# Start of PhaseEnvelopeData_clear

`PhaseEnvelopeData_clear` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_clear', self, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_clear`, 'returnType') = 'void'
attr(`PhaseEnvelopeData_clear`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData')
class(`PhaseEnvelopeData_clear`) = c("SWIGFunction", class('PhaseEnvelopeData_clear'))

# Start of PhaseEnvelopeData_insert_variables

`PhaseEnvelopeData_insert_variables` = function(self, T, p, rhomolar_liq, rhomolar_vap, hmolar_liq, hmolar_vap, smolar_liq, smolar_vap, x, y, i)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  
  
  
  
  
  
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  if (inherits(y, "ExternalReference")) y = slot(y,"ref") 
  i = as.integer(i);
  
  if(length(i) > 1) {
    warning("using only the first element of i");
  };
  
  ;.Call('R_swig_PhaseEnvelopeData_insert_variables', self, T, p, rhomolar_liq, rhomolar_vap, hmolar_liq, hmolar_vap, smolar_liq, smolar_vap, x, y, i, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_insert_variables`, 'returnType') = 'void'
attr(`PhaseEnvelopeData_insert_variables`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData', 'numeric', 'numeric', 'numeric', 'numeric', 'numeric', 'numeric', 'numeric', 'numeric', '_p_std__vectorT_CoolPropDbl_std__allocatorT_CoolPropDbl_t_t', '_p_std__vectorT_CoolPropDbl_std__allocatorT_CoolPropDbl_t_t', 'integer')
class(`PhaseEnvelopeData_insert_variables`) = c("SWIGFunction", class('PhaseEnvelopeData_insert_variables'))

# Start of PhaseEnvelopeData_store_variables

`PhaseEnvelopeData_store_variables` = function(self, T, p, rhomolar_liq, rhomolar_vap, hmolar_liq, hmolar_vap, smolar_liq, smolar_vap, x, y)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  
  
  
  
  
  
  
  if (inherits(x, "ExternalReference")) x = slot(x,"ref") 
  if (inherits(y, "ExternalReference")) y = slot(y,"ref") 
  ;.Call('R_swig_PhaseEnvelopeData_store_variables', self, T, p, rhomolar_liq, rhomolar_vap, hmolar_liq, hmolar_vap, smolar_liq, smolar_vap, x, y, PACKAGE='CoolProp');
  
}

attr(`PhaseEnvelopeData_store_variables`, 'returnType') = 'void'
attr(`PhaseEnvelopeData_store_variables`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData', 'numeric', 'numeric', 'numeric', 'numeric', 'numeric', 'numeric', 'numeric', 'numeric', '_p_std__vectorT_CoolPropDbl_std__allocatorT_CoolPropDbl_t_t', '_p_std__vectorT_CoolPropDbl_std__allocatorT_CoolPropDbl_t_t')
class(`PhaseEnvelopeData_store_variables`) = c("SWIGFunction", class('PhaseEnvelopeData_store_variables'))

# Start of delete_PhaseEnvelopeData

`delete_PhaseEnvelopeData` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_PhaseEnvelopeData', self, PACKAGE='CoolProp');
  
}

attr(`delete_PhaseEnvelopeData`, 'returnType') = 'void'
attr(`delete_PhaseEnvelopeData`, "inputTypes") = c('_p_CoolProp__PhaseEnvelopeData')
class(`delete_PhaseEnvelopeData`) = c("SWIGFunction", class('delete_PhaseEnvelopeData'))

# Start of accessor method for CoolProp::PhaseEnvelopeData
setMethod('$', '_p_CoolProp__PhaseEnvelopeData', function(x, name)

{
  accessorFuns = list('TypeI' = PhaseEnvelopeData_TypeI_get, 'built' = PhaseEnvelopeData_built_get, 'iTsat_max' = PhaseEnvelopeData_iTsat_max_get, 'ipsat_max' = PhaseEnvelopeData_ipsat_max_get, 'icrit' = PhaseEnvelopeData_icrit_get, 'T' = PhaseEnvelopeData_T_get, 'p' = PhaseEnvelopeData_p_get, 'lnT' = PhaseEnvelopeData_lnT_get, 'lnp' = PhaseEnvelopeData_lnp_get, 'rhomolar_liq' = PhaseEnvelopeData_rhomolar_liq_get, 'rhomolar_vap' = PhaseEnvelopeData_rhomolar_vap_get, 'lnrhomolar_liq' = PhaseEnvelopeData_lnrhomolar_liq_get, 'lnrhomolar_vap' = PhaseEnvelopeData_lnrhomolar_vap_get, 'hmolar_liq' = PhaseEnvelopeData_hmolar_liq_get, 'hmolar_vap' = PhaseEnvelopeData_hmolar_vap_get, 'smolar_liq' = PhaseEnvelopeData_smolar_liq_get, 'smolar_vap' = PhaseEnvelopeData_smolar_vap_get, 'Q' = PhaseEnvelopeData_Q_get, 'cpmolar_liq' = PhaseEnvelopeData_cpmolar_liq_get, 'cpmolar_vap' = PhaseEnvelopeData_cpmolar_vap_get, 'cvmolar_liq' = PhaseEnvelopeData_cvmolar_liq_get, 'cvmolar_vap' = PhaseEnvelopeData_cvmolar_vap_get, 'viscosity_liq' = PhaseEnvelopeData_viscosity_liq_get, 'viscosity_vap' = PhaseEnvelopeData_viscosity_vap_get, 'conductivity_liq' = PhaseEnvelopeData_conductivity_liq_get, 'conductivity_vap' = PhaseEnvelopeData_conductivity_vap_get, 'speed_sound_vap' = PhaseEnvelopeData_speed_sound_vap_get, 'K' = PhaseEnvelopeData_K_get, 'lnK' = PhaseEnvelopeData_lnK_get, 'x' = PhaseEnvelopeData_x_get, 'y' = PhaseEnvelopeData_y_get, 'resize' = PhaseEnvelopeData_resize, 'clear' = PhaseEnvelopeData_clear, 'insert_variables' = PhaseEnvelopeData_insert_variables, 'store_variables' = PhaseEnvelopeData_store_variables);
  vaccessors = c('TypeI', 'built', 'iTsat_max', 'ipsat_max', 'icrit', 'T', 'p', 'lnT', 'lnp', 'rhomolar_liq', 'rhomolar_vap', 'lnrhomolar_liq', 'lnrhomolar_vap', 'hmolar_liq', 'hmolar_vap', 'smolar_liq', 'smolar_vap', 'Q', 'cpmolar_liq', 'cpmolar_vap', 'cvmolar_liq', 'cvmolar_vap', 'viscosity_liq', 'viscosity_vap', 'conductivity_liq', 'conductivity_vap', 'speed_sound_vap', 'K', 'lnK', 'x', 'y');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  if (is.na(match(name, vaccessors))) function(...){
    f(x, ...)
  } else f(x);
}


);
# end of accessor method for CoolProp::PhaseEnvelopeData
# Start of accessor method for CoolProp::PhaseEnvelopeData
setMethod('$<-', '_p_CoolProp__PhaseEnvelopeData', function(x, name, value)

{
  accessorFuns = list('TypeI' = PhaseEnvelopeData_TypeI_set, 'built' = PhaseEnvelopeData_built_set, 'iTsat_max' = PhaseEnvelopeData_iTsat_max_set, 'ipsat_max' = PhaseEnvelopeData_ipsat_max_set, 'icrit' = PhaseEnvelopeData_icrit_set, 'T' = PhaseEnvelopeData_T_set, 'p' = PhaseEnvelopeData_p_set, 'lnT' = PhaseEnvelopeData_lnT_set, 'lnp' = PhaseEnvelopeData_lnp_set, 'rhomolar_liq' = PhaseEnvelopeData_rhomolar_liq_set, 'rhomolar_vap' = PhaseEnvelopeData_rhomolar_vap_set, 'lnrhomolar_liq' = PhaseEnvelopeData_lnrhomolar_liq_set, 'lnrhomolar_vap' = PhaseEnvelopeData_lnrhomolar_vap_set, 'hmolar_liq' = PhaseEnvelopeData_hmolar_liq_set, 'hmolar_vap' = PhaseEnvelopeData_hmolar_vap_set, 'smolar_liq' = PhaseEnvelopeData_smolar_liq_set, 'smolar_vap' = PhaseEnvelopeData_smolar_vap_set, 'Q' = PhaseEnvelopeData_Q_set, 'cpmolar_liq' = PhaseEnvelopeData_cpmolar_liq_set, 'cpmolar_vap' = PhaseEnvelopeData_cpmolar_vap_set, 'cvmolar_liq' = PhaseEnvelopeData_cvmolar_liq_set, 'cvmolar_vap' = PhaseEnvelopeData_cvmolar_vap_set, 'viscosity_liq' = PhaseEnvelopeData_viscosity_liq_set, 'viscosity_vap' = PhaseEnvelopeData_viscosity_vap_set, 'conductivity_liq' = PhaseEnvelopeData_conductivity_liq_set, 'conductivity_vap' = PhaseEnvelopeData_conductivity_vap_set, 'speed_sound_vap' = PhaseEnvelopeData_speed_sound_vap_set, 'K' = PhaseEnvelopeData_K_set, 'lnK' = PhaseEnvelopeData_lnK_set, 'x' = PhaseEnvelopeData_x_set, 'y' = PhaseEnvelopeData_y_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_CoolProp__PhaseEnvelopeData', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('TypeI' = PhaseEnvelopeData_TypeI_set, 'built' = PhaseEnvelopeData_built_set, 'iTsat_max' = PhaseEnvelopeData_iTsat_max_set, 'ipsat_max' = PhaseEnvelopeData_ipsat_max_set, 'icrit' = PhaseEnvelopeData_icrit_set, 'T' = PhaseEnvelopeData_T_set, 'p' = PhaseEnvelopeData_p_set, 'lnT' = PhaseEnvelopeData_lnT_set, 'lnp' = PhaseEnvelopeData_lnp_set, 'rhomolar_liq' = PhaseEnvelopeData_rhomolar_liq_set, 'rhomolar_vap' = PhaseEnvelopeData_rhomolar_vap_set, 'lnrhomolar_liq' = PhaseEnvelopeData_lnrhomolar_liq_set, 'lnrhomolar_vap' = PhaseEnvelopeData_lnrhomolar_vap_set, 'hmolar_liq' = PhaseEnvelopeData_hmolar_liq_set, 'hmolar_vap' = PhaseEnvelopeData_hmolar_vap_set, 'smolar_liq' = PhaseEnvelopeData_smolar_liq_set, 'smolar_vap' = PhaseEnvelopeData_smolar_vap_set, 'Q' = PhaseEnvelopeData_Q_set, 'cpmolar_liq' = PhaseEnvelopeData_cpmolar_liq_set, 'cpmolar_vap' = PhaseEnvelopeData_cpmolar_vap_set, 'cvmolar_liq' = PhaseEnvelopeData_cvmolar_liq_set, 'cvmolar_vap' = PhaseEnvelopeData_cvmolar_vap_set, 'viscosity_liq' = PhaseEnvelopeData_viscosity_liq_set, 'viscosity_vap' = PhaseEnvelopeData_viscosity_vap_set, 'conductivity_liq' = PhaseEnvelopeData_conductivity_liq_set, 'conductivity_vap' = PhaseEnvelopeData_conductivity_vap_set, 'speed_sound_vap' = PhaseEnvelopeData_speed_sound_vap_set, 'K' = PhaseEnvelopeData_K_set, 'lnK' = PhaseEnvelopeData_lnK_set, 'x' = PhaseEnvelopeData_x_set, 'y' = PhaseEnvelopeData_y_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for CoolProp::PhaseEnvelopeData
setMethod('delete', '_p_CoolProp__PhaseEnvelopeData', function(obj) {delete_CoolProp__PhaseEnvelopeData(obj)})
defineEnumeration('_configuration_keys',
                    .values = c(
                        'NORMALIZE_GAS_CONSTANTS' = 0, 
                        'CRITICAL_WITHIN_1UK' = 1, 
                        'CRITICAL_SPLINES_ENABLED' = 2, 
                        'SAVE_RAW_TABLES' = 3, 
                        'ALTERNATIVE_TABLES_DIRECTORY' = 4, 
                        'ALTERNATIVE_REFPROP_PATH' = 5, 
                        'ALTERNATIVE_REFPROP_HMX_BNC_PATH' = 6, 
                        'REFPROP_DONT_ESTIMATE_INTERACTION_PARAMETERS' = 7, 
                        'REFPROP_USE_GERG' = 8, 
                        'REFPROP_USE_PENGROBINSON' = 9, 
                        'MAXIMUM_TABLE_DIRECTORY_SIZE_IN_GB' = 10, 
                        'DONT_CHECK_PROPERTY_LIMITS' = 11, 
                        'HENRYS_LAW_TO_GENERATE_VLE_GUESSES' = 12, 
                        'PHASE_ENVELOPE_STARTING_PRESSURE_PA' = 13, 
                        'R_U_CODATA' = 14, 
                        'VTPR_UNIFAQ_PATH' = 15
))
defineEnumeration('_ConfigurationDataTypes',
                    .values = c(
                        'CONFIGURATION_NOT_DEFINED_TYPE' = 0, 
                        'CONFIGURATION_BOOL_TYPE' = 1, 
                        'CONFIGURATION_DOUBLE_TYPE' = 2, 
                        'CONFIGURATION_INTEGER_TYPE' = 3, 
                        'CONFIGURATION_STRING_TYPE' = 4, 
                        'CONFIGURATION_ENDOFLIST_TYPE' = 5
))
# Start of config_key_to_string

`config_key_to_string` = function(keys, .copy = FALSE)
{
  keys = enumToInteger(keys, "_configuration_keys"); 
  
  if(length(keys) > 1) {
    warning("using only the first element of keys");
  };
  
  ;.Call('R_swig_config_key_to_string', keys, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`config_key_to_string`, 'returnType') = 'character'
attr(`config_key_to_string`, "inputTypes") = c('character')
class(`config_key_to_string`) = c("SWIGFunction", class('config_key_to_string'))

# Start of config_string_to_key

`config_string_to_key` = function(s, .copy = FALSE)
{
  s = as(s, "character"); 
  ;ans = .Call('R_swig_config_string_to_key', s, as.logical(.copy), PACKAGE='CoolProp');
  ans = enumFromInteger(ans, "_configuration_keys");
  
  ans
  
}

attr(`config_string_to_key`, 'returnType') = 'character'
attr(`config_string_to_key`, "inputTypes") = c('character')
class(`config_string_to_key`) = c("SWIGFunction", class('config_string_to_key'))

# Start of config_key_description

`config_key_description__SWIG_0` = function(keys, .copy = FALSE)
{
  keys = enumToInteger(keys, "_configuration_keys"); 
  
  if(length(keys) > 1) {
    warning("using only the first element of keys");
  };
  
  ;.Call('R_swig_config_key_description__SWIG_0', keys, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`config_key_description__SWIG_0`, 'returnType') = 'character'
attr(`config_key_description__SWIG_0`, "inputTypes") = c('character')
class(`config_key_description__SWIG_0`) = c("SWIGFunction", class('config_key_description__SWIG_0'))

# Start of config_key_description

`config_key_description__SWIG_1` = function(key, .copy = FALSE)
{
  key = as(key, "character"); 
  ;.Call('R_swig_config_key_description__SWIG_1', key, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`config_key_description__SWIG_1`, 'returnType') = 'character'
attr(`config_key_description__SWIG_1`, "inputTypes") = c('character')
class(`config_key_description__SWIG_1`) = c("SWIGFunction", class('config_key_description__SWIG_1'))

`config_key_description` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 1) {
    if (is.character(argv[[1]]) && length(argv[[1]]) == 1) {
      f <- config_key_description__SWIG_0; 
    }
    else if (is.character(argv[[1]]) && length(argv[[1]]) == 1) {
      f <- config_key_description__SWIG_1; 
    }
  } else {
    stop("cannot find overloaded function for config_key_description with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of new_ConfigurationItem

`ConfigurationItem__SWIG_0` = function(key, val)
{
  key = enumToInteger(key, "_configuration_keys"); 
  
  if(length(key) > 1) {
    warning("using only the first element of key");
  };
  
  val = as.logical(val);
  ;ans = .Call('R_swig_new_ConfigurationItem__SWIG_0', key, val, PACKAGE='CoolProp');
  ans <- new("_p_CoolProp__ConfigurationItem", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_ConfigurationItem)
  ans
  
}

attr(`ConfigurationItem__SWIG_0`, 'returnType') = '_p_CoolProp__ConfigurationItem'
attr(`ConfigurationItem__SWIG_0`, "inputTypes") = c('character', 'logical')
class(`ConfigurationItem__SWIG_0`) = c("SWIGFunction", class('ConfigurationItem__SWIG_0'))

# Start of new_ConfigurationItem

`ConfigurationItem__SWIG_1` = function(key, val)
{
  key = enumToInteger(key, "_configuration_keys"); 
  
  if(length(key) > 1) {
    warning("using only the first element of key");
  };
  
  val = as.integer(val);
  
  if(length(val) > 1) {
    warning("using only the first element of val");
  };
  
  ;ans = .Call('R_swig_new_ConfigurationItem__SWIG_1', key, val, PACKAGE='CoolProp');
  ans <- new("_p_CoolProp__ConfigurationItem", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_ConfigurationItem)
  ans
  
}

attr(`ConfigurationItem__SWIG_1`, 'returnType') = '_p_CoolProp__ConfigurationItem'
attr(`ConfigurationItem__SWIG_1`, "inputTypes") = c('character', 'integer')
class(`ConfigurationItem__SWIG_1`) = c("SWIGFunction", class('ConfigurationItem__SWIG_1'))

# Start of new_ConfigurationItem

`ConfigurationItem__SWIG_2` = function(key, val)
{
  key = enumToInteger(key, "_configuration_keys"); 
  
  if(length(key) > 1) {
    warning("using only the first element of key");
  };
  
  
  ;ans = .Call('R_swig_new_ConfigurationItem__SWIG_2', key, val, PACKAGE='CoolProp');
  ans <- new("_p_CoolProp__ConfigurationItem", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_ConfigurationItem)
  ans
  
}

attr(`ConfigurationItem__SWIG_2`, 'returnType') = '_p_CoolProp__ConfigurationItem'
attr(`ConfigurationItem__SWIG_2`, "inputTypes") = c('character', 'numeric')
class(`ConfigurationItem__SWIG_2`) = c("SWIGFunction", class('ConfigurationItem__SWIG_2'))

# Start of new_ConfigurationItem

`ConfigurationItem__SWIG_3` = function(key, val)
{
  key = enumToInteger(key, "_configuration_keys"); 
  
  if(length(key) > 1) {
    warning("using only the first element of key");
  };
  
  val = as(val, "character"); 
  ;ans = .Call('R_swig_new_ConfigurationItem__SWIG_3', key, val, PACKAGE='CoolProp');
  ans <- new("_p_CoolProp__ConfigurationItem", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_ConfigurationItem)
  ans
  
}

attr(`ConfigurationItem__SWIG_3`, 'returnType') = '_p_CoolProp__ConfigurationItem'
attr(`ConfigurationItem__SWIG_3`, "inputTypes") = c('character', 'character')
class(`ConfigurationItem__SWIG_3`) = c("SWIGFunction", class('ConfigurationItem__SWIG_3'))

# Start of new_ConfigurationItem

`ConfigurationItem__SWIG_4` = function(key, val)
{
  key = enumToInteger(key, "_configuration_keys"); 
  
  if(length(key) > 1) {
    warning("using only the first element of key");
  };
  
  val = as(val, "character"); 
  ;ans = .Call('R_swig_new_ConfigurationItem__SWIG_4', key, val, PACKAGE='CoolProp');
  ans <- new("_p_CoolProp__ConfigurationItem", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_ConfigurationItem)
  ans
  
}

attr(`ConfigurationItem__SWIG_4`, 'returnType') = '_p_CoolProp__ConfigurationItem'
attr(`ConfigurationItem__SWIG_4`, "inputTypes") = c('character', 'character')
class(`ConfigurationItem__SWIG_4`) = c("SWIGFunction", class('ConfigurationItem__SWIG_4'))

`ConfigurationItem` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 5
  if (argc == 2) {
    if (is.character(argv[[1]]) && length(argv[[1]]) == 1 && ( is.logical(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- ConfigurationItem__SWIG_0; 
    }
    else if (is.character(argv[[1]]) && length(argv[[1]]) == 1 && ( (is.integer(argv[[2]]) || is.numeric(argv[[2]])) && length(argv[[2]]) == 1 )) {
      f <- ConfigurationItem__SWIG_1; 
    }
    else if (is.character(argv[[1]]) && length(argv[[1]]) == 1 && ( is.numeric(argv[[2]]) && length(argv[[2]]) == 1 )) {
      f <- ConfigurationItem__SWIG_2; 
    }
    else if (is.character(argv[[1]]) && length(argv[[1]]) == 1 && is.character(argv[[2]]) && length(argv[[2]]) == 1) {
      f <- ConfigurationItem__SWIG_4; 
    }
    else if (is.character(argv[[1]]) && length(argv[[1]]) == 1 && is.character(argv[[2]])) {
      f <- ConfigurationItem__SWIG_3; 
    }
  } else {
    stop("cannot find overloaded function for ConfigurationItem with argtypes (",toString(argtypes),")");
  };
  f(...);
}

# Dispatch function
# Start of ConfigurationItem_set_bool

`ConfigurationItem_set_bool` = function(self, val)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  val = as.logical(val);
  ;.Call('R_swig_ConfigurationItem_set_bool', self, val, PACKAGE='CoolProp');
  
}

attr(`ConfigurationItem_set_bool`, 'returnType') = 'void'
attr(`ConfigurationItem_set_bool`, "inputTypes") = c('_p_CoolProp__ConfigurationItem', 'logical')
class(`ConfigurationItem_set_bool`) = c("SWIGFunction", class('ConfigurationItem_set_bool'))

# Start of ConfigurationItem_set_integer

`ConfigurationItem_set_integer` = function(self, val)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  val = as.integer(val);
  
  if(length(val) > 1) {
    warning("using only the first element of val");
  };
  
  ;.Call('R_swig_ConfigurationItem_set_integer', self, val, PACKAGE='CoolProp');
  
}

attr(`ConfigurationItem_set_integer`, 'returnType') = 'void'
attr(`ConfigurationItem_set_integer`, "inputTypes") = c('_p_CoolProp__ConfigurationItem', 'integer')
class(`ConfigurationItem_set_integer`) = c("SWIGFunction", class('ConfigurationItem_set_integer'))

# Start of ConfigurationItem_set_double

`ConfigurationItem_set_double` = function(self, val)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  
  ;.Call('R_swig_ConfigurationItem_set_double', self, val, PACKAGE='CoolProp');
  
}

attr(`ConfigurationItem_set_double`, 'returnType') = 'void'
attr(`ConfigurationItem_set_double`, "inputTypes") = c('_p_CoolProp__ConfigurationItem', 'numeric')
class(`ConfigurationItem_set_double`) = c("SWIGFunction", class('ConfigurationItem_set_double'))

# Start of ConfigurationItem_set_string

`ConfigurationItem_set_string` = function(self, val)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  val = as(val, "character"); 
  ;.Call('R_swig_ConfigurationItem_set_string', self, val, PACKAGE='CoolProp');
  
}

attr(`ConfigurationItem_set_string`, 'returnType') = 'void'
attr(`ConfigurationItem_set_string`, "inputTypes") = c('_p_CoolProp__ConfigurationItem', 'character')
class(`ConfigurationItem_set_string`) = c("SWIGFunction", class('ConfigurationItem_set_string'))

# Start of ConfigurationItem_get_key

`ConfigurationItem_get_key` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_ConfigurationItem_get_key', self, as.logical(.copy), PACKAGE='CoolProp');
  ans = enumFromInteger(ans, "_configuration_keys");
  
  ans
  
}

attr(`ConfigurationItem_get_key`, 'returnType') = 'character'
attr(`ConfigurationItem_get_key`, "inputTypes") = c('_p_CoolProp__ConfigurationItem')
class(`ConfigurationItem_get_key`) = c("SWIGFunction", class('ConfigurationItem_get_key'))

# Start of delete_ConfigurationItem

`delete_ConfigurationItem` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_ConfigurationItem', self, PACKAGE='CoolProp');
  
}

attr(`delete_ConfigurationItem`, 'returnType') = 'void'
attr(`delete_ConfigurationItem`, "inputTypes") = c('_p_CoolProp__ConfigurationItem')
class(`delete_ConfigurationItem`) = c("SWIGFunction", class('delete_ConfigurationItem'))

# Start of accessor method for CoolProp::ConfigurationItem
setMethod('$', '_p_CoolProp__ConfigurationItem', function(x, name)

{
  accessorFuns = list('set_bool' = ConfigurationItem_set_bool, 'set_integer' = ConfigurationItem_set_integer, 'set_double' = ConfigurationItem_set_double, 'set_string' = ConfigurationItem_set_string, 'get_key' = ConfigurationItem_get_key);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for CoolProp::ConfigurationItem
setMethod('delete', '_p_CoolProp__ConfigurationItem', function(obj) {delete_CoolProp__ConfigurationItem(obj)})
# Start of new_Configuration

`Configuration` = function()
{
  ;ans = .Call('R_swig_new_Configuration', PACKAGE='CoolProp');
  ans <- new("_p_CoolProp__Configuration", ref=ans) ;
  
  reg.finalizer(ans@ref, delete_Configuration)
  ans
  
}

attr(`Configuration`, 'returnType') = '_p_CoolProp__Configuration'
class(`Configuration`) = c("SWIGFunction", class('Configuration'))

# Start of delete_Configuration

`delete_Configuration` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_delete_Configuration', self, PACKAGE='CoolProp');
  
}

attr(`delete_Configuration`, 'returnType') = 'void'
attr(`delete_Configuration`, "inputTypes") = c('_p_CoolProp__Configuration')
class(`delete_Configuration`) = c("SWIGFunction", class('delete_Configuration'))

# Start of Configuration_get_item

`Configuration_get_item` = function(self, key, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  key = enumToInteger(key, "_configuration_keys"); 
  
  if(length(key) > 1) {
    warning("using only the first element of key");
  };
  
  ;ans = .Call('R_swig_Configuration_get_item', self, key, as.logical(.copy), PACKAGE='CoolProp');
  ans <- new("_p_CoolProp__ConfigurationItem", ref=ans) ;
  
  ans
  
}

attr(`Configuration_get_item`, 'returnType') = '_p_CoolProp__ConfigurationItem'
attr(`Configuration_get_item`, "inputTypes") = c('_p_CoolProp__Configuration', 'character')
class(`Configuration_get_item`) = c("SWIGFunction", class('Configuration_get_item'))

# Start of Configuration_add_item

`Configuration_add_item` = function(self, item)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  if (inherits(item, "ExternalReference")) item = slot(item,"ref") 
  ;.Call('R_swig_Configuration_add_item', self, item, PACKAGE='CoolProp');
  
}

attr(`Configuration_add_item`, 'returnType') = 'void'
attr(`Configuration_add_item`, "inputTypes") = c('_p_CoolProp__Configuration', '_p_CoolProp__ConfigurationItem')
class(`Configuration_add_item`) = c("SWIGFunction", class('Configuration_add_item'))

# Start of Configuration_get_items

`Configuration_get_items` = function(self, .copy = FALSE)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;ans = .Call('R_swig_Configuration_get_items', self, as.logical(.copy), PACKAGE='CoolProp');
  ans <- new("_p_std__mapT_configuration_keys_CoolProp__ConfigurationItem_t", ref=ans) ;
  
  ans
  
}

attr(`Configuration_get_items`, 'returnType') = '_p_std__mapT_configuration_keys_CoolProp__ConfigurationItem_t'
attr(`Configuration_get_items`, "inputTypes") = c('_p_CoolProp__Configuration')
class(`Configuration_get_items`) = c("SWIGFunction", class('Configuration_get_items'))

# Start of Configuration_set_defaults

`Configuration_set_defaults` = function(self)
{
  if (inherits(self, "ExternalReference")) self = slot(self,"ref") 
  ;.Call('R_swig_Configuration_set_defaults', self, PACKAGE='CoolProp');
  
}

attr(`Configuration_set_defaults`, 'returnType') = 'void'
attr(`Configuration_set_defaults`, "inputTypes") = c('_p_CoolProp__Configuration')
class(`Configuration_set_defaults`) = c("SWIGFunction", class('Configuration_set_defaults'))

# Start of accessor method for CoolProp::Configuration
setMethod('$', '_p_CoolProp__Configuration', function(x, name)

{
  accessorFuns = list('get_item' = Configuration_get_item, 'add_item' = Configuration_add_item, 'get_items' = Configuration_get_items, 'set_defaults' = Configuration_set_defaults);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  function(...){
    f(x, ...)
  };
}


);
# end of accessor method for CoolProp::Configuration
setMethod('delete', '_p_CoolProp__Configuration', function(obj) {delete_CoolProp__Configuration(obj)})
# Start of get_config_bool

`get_config_bool` = function(key, .copy = FALSE)
{
  key = enumToInteger(key, "_configuration_keys"); 
  
  if(length(key) > 1) {
    warning("using only the first element of key");
  };
  
  ;.Call('R_swig_get_config_bool', key, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`get_config_bool`, 'returnType') = 'logical'
attr(`get_config_bool`, "inputTypes") = c('character')
class(`get_config_bool`) = c("SWIGFunction", class('get_config_bool'))

# Start of get_config_double

`get_config_double` = function(key, .copy = FALSE)
{
  key = enumToInteger(key, "_configuration_keys"); 
  
  if(length(key) > 1) {
    warning("using only the first element of key");
  };
  
  ;.Call('R_swig_get_config_double', key, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`get_config_double`, 'returnType') = 'numeric'
attr(`get_config_double`, "inputTypes") = c('character')
class(`get_config_double`) = c("SWIGFunction", class('get_config_double'))

# Start of get_config_string

`get_config_string` = function(key, .copy = FALSE)
{
  key = enumToInteger(key, "_configuration_keys"); 
  
  if(length(key) > 1) {
    warning("using only the first element of key");
  };
  
  ;.Call('R_swig_get_config_string', key, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`get_config_string`, 'returnType') = 'character'
attr(`get_config_string`, "inputTypes") = c('character')
class(`get_config_string`) = c("SWIGFunction", class('get_config_string'))

# Start of get_config_as_json_string

`get_config_as_json_string` = function(.copy = FALSE)
{
  ;.Call('R_swig_get_config_as_json_string', as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`get_config_as_json_string`, 'returnType') = 'character'
class(`get_config_as_json_string`) = c("SWIGFunction", class('get_config_as_json_string'))

# Start of set_config_bool

`set_config_bool` = function(key, val)
{
  key = enumToInteger(key, "_configuration_keys"); 
  
  if(length(key) > 1) {
    warning("using only the first element of key");
  };
  
  val = as.logical(val);
  ;.Call('R_swig_set_config_bool', key, val, PACKAGE='CoolProp');
  
}

attr(`set_config_bool`, 'returnType') = 'void'
attr(`set_config_bool`, "inputTypes") = c('character', 'logical')
class(`set_config_bool`) = c("SWIGFunction", class('set_config_bool'))

# Start of set_config_double

`set_config_double` = function(key, val)
{
  key = enumToInteger(key, "_configuration_keys"); 
  
  if(length(key) > 1) {
    warning("using only the first element of key");
  };
  
  
  ;.Call('R_swig_set_config_double', key, val, PACKAGE='CoolProp');
  
}

attr(`set_config_double`, 'returnType') = 'void'
attr(`set_config_double`, "inputTypes") = c('character', 'numeric')
class(`set_config_double`) = c("SWIGFunction", class('set_config_double'))

# Start of set_config_string

`set_config_string` = function(key, val)
{
  key = enumToInteger(key, "_configuration_keys"); 
  
  if(length(key) > 1) {
    warning("using only the first element of key");
  };
  
  val = as(val, "character"); 
  ;.Call('R_swig_set_config_string', key, val, PACKAGE='CoolProp');
  
}

attr(`set_config_string`, 'returnType') = 'void'
attr(`set_config_string`, "inputTypes") = c('character', 'character')
class(`set_config_string`) = c("SWIGFunction", class('set_config_string'))

# Start of set_config_as_json_string

`set_config_as_json_string` = function(s)
{
  s = as(s, "character"); 
  ;.Call('R_swig_set_config_as_json_string', s, PACKAGE='CoolProp');
  
}

attr(`set_config_as_json_string`, 'returnType') = 'void'
attr(`set_config_as_json_string`, "inputTypes") = c('character')
class(`set_config_as_json_string`) = c("SWIGFunction", class('set_config_as_json_string'))

# Start of HAPropsSI

`HAPropsSI` = function(OutputName, Input1Name, Input1, Input2Name, Input2, Input3Name, Input3, .copy = FALSE)
{
  OutputName = as(OutputName, "character"); 
  Input1Name = as(Input1Name, "character"); 
  
  Input2Name = as(Input2Name, "character"); 
  
  Input3Name = as(Input3Name, "character"); 
  
  ;.Call('R_swig_HAPropsSI', OutputName, Input1Name, Input1, Input2Name, Input2, Input3Name, Input3, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`HAPropsSI`, 'returnType') = 'numeric'
attr(`HAPropsSI`, "inputTypes") = c('character', 'character', 'numeric', 'character', 'numeric', 'character', 'numeric')
class(`HAPropsSI`) = c("SWIGFunction", class('HAPropsSI'))

# Start of HAProps

`HAProps` = function(OutputName, Input1Name, Input1, Input2Name, Input2, Input3Name, Input3, .copy = FALSE)
{
  OutputName = as(OutputName, "character"); 
  Input1Name = as(Input1Name, "character"); 
  
  Input2Name = as(Input2Name, "character"); 
  
  Input3Name = as(Input3Name, "character"); 
  
  ;.Call('R_swig_HAProps', OutputName, Input1Name, Input1, Input2Name, Input2, Input3Name, Input3, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`HAProps`, 'returnType') = 'numeric'
attr(`HAProps`, "inputTypes") = c('character', 'character', 'numeric', 'character', 'numeric', 'character', 'numeric')
class(`HAProps`) = c("SWIGFunction", class('HAProps'))

# Start of HAProps_Aux

`HAProps_Aux` = function(OutputName, T, p, W, units, .copy = FALSE)
{
  OutputName = as(OutputName, "character"); 
  
  
  
  units = as(units, "character"); 
  ;.Call('R_swig_HAProps_Aux', OutputName, T, p, W, units, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`HAProps_Aux`, 'returnType') = 'numeric'
attr(`HAProps_Aux`, "inputTypes") = c('character', 'numeric', 'numeric', 'numeric', 'character')
class(`HAProps_Aux`) = c("SWIGFunction", class('HAProps_Aux'))

# Start of IceProps

`IceProps` = function(Name, T, p, .copy = FALSE)
{
  Name = as(Name, "character"); 
  
  
  ;.Call('R_swig_IceProps', Name, T, p, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`IceProps`, 'returnType') = 'numeric'
attr(`IceProps`, "inputTypes") = c('character', 'numeric', 'numeric')
class(`IceProps`) = c("SWIGFunction", class('IceProps'))

# Start of UseVirialCorrelations

`UseVirialCorrelations` = function(flag)
{
  flag = as.integer(flag);
  
  if(length(flag) > 1) {
    warning("using only the first element of flag");
  };
  
  ;.Call('R_swig_UseVirialCorrelations', flag, PACKAGE='CoolProp');
  
}

attr(`UseVirialCorrelations`, 'returnType') = 'void'
attr(`UseVirialCorrelations`, "inputTypes") = c('integer')
class(`UseVirialCorrelations`) = c("SWIGFunction", class('UseVirialCorrelations'))

# Start of UseIsothermCompressCorrelation

`UseIsothermCompressCorrelation` = function(flag)
{
  flag = as.integer(flag);
  
  if(length(flag) > 1) {
    warning("using only the first element of flag");
  };
  
  ;.Call('R_swig_UseIsothermCompressCorrelation', flag, PACKAGE='CoolProp');
  
}

attr(`UseIsothermCompressCorrelation`, 'returnType') = 'void'
attr(`UseIsothermCompressCorrelation`, "inputTypes") = c('integer')
class(`UseIsothermCompressCorrelation`) = c("SWIGFunction", class('UseIsothermCompressCorrelation'))

# Start of UseIdealGasEnthalpyCorrelations

`UseIdealGasEnthalpyCorrelations` = function(flag)
{
  flag = as.integer(flag);
  
  if(length(flag) > 1) {
    warning("using only the first element of flag");
  };
  
  ;.Call('R_swig_UseIdealGasEnthalpyCorrelations', flag, PACKAGE='CoolProp');
  
}

attr(`UseIdealGasEnthalpyCorrelations`, 'returnType') = 'void'
attr(`UseIdealGasEnthalpyCorrelations`, "inputTypes") = c('integer')
class(`UseIdealGasEnthalpyCorrelations`) = c("SWIGFunction", class('UseIdealGasEnthalpyCorrelations'))

# Start of HAHelp

`HAHelp` = function()
{
  ;.Call('R_swig_HAHelp', PACKAGE='CoolProp');
  
}

attr(`HAHelp`, 'returnType') = 'void'
class(`HAHelp`) = c("SWIGFunction", class('HAHelp'))

# Start of returnHumAirCode

`returnHumAirCode` = function(Code, .copy = FALSE)
{
  Code = as(Code, "character"); 
  ;.Call('R_swig_returnHumAirCode', Code, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`returnHumAirCode`, 'returnType') = 'integer'
attr(`returnHumAirCode`, "inputTypes") = c('character')
class(`returnHumAirCode`) = c("SWIGFunction", class('returnHumAirCode'))

# Start of cair_sat

`cair_sat` = function(T, .copy = FALSE)
{
  ;.Call('R_swig_cair_sat', T, as.logical(.copy), PACKAGE='CoolProp');
  
}

attr(`cair_sat`, 'returnType') = 'numeric'
attr(`cair_sat`, "inputTypes") = c('numeric')
class(`cair_sat`) = c("SWIGFunction", class('cair_sat'))


